<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.6">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Kay Haw&#39;s Blog Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Kay Haw&#39;s Blog Blog Atom Feed">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" integrity="sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc" crossorigin="anonymous"><title data-react-helmet="true">Hadoop 3.x学习笔记(6) | Kay Haw&#x27;s Blog</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://kayhaw.github.io/blog/2022/02/10/Learning-Hadoop3.x-06"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_tag" content="default"><meta data-react-helmet="true" property="og:title" content="Hadoop 3.x学习笔记(6) | Kay Haw&#x27;s Blog"><meta data-react-helmet="true" name="description" content="Hadoop 3.1.3学习笔记(6)"><meta data-react-helmet="true" property="og:description" content="Hadoop 3.1.3学习笔记(6)"><meta data-react-helmet="true" property="og:type" content="article"><meta data-react-helmet="true" property="article:published_time" content="2022-02-10T00:00:00.000Z"><meta data-react-helmet="true" property="article:author" content="https://github.com/kayhaw"><meta data-react-helmet="true" property="article:tag" content="Hadoop,BigData"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://kayhaw.github.io/blog/2022/02/10/Learning-Hadoop3.x-06"><link data-react-helmet="true" rel="alternate" href="https://kayhaw.github.io/blog/2022/02/10/Learning-Hadoop3.x-06" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://kayhaw.github.io/blog/2022/02/10/Learning-Hadoop3.x-06" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.0138175c.css">
<link rel="preload" href="/assets/js/runtime~main.5c7121e2.js" as="script">
<link rel="preload" href="/assets/js/main.eedec005.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="Kay Haw&#x27;s Blog" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo.svg" alt="Kay Haw&#x27;s Blog" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">Kay Haw&#x27;s Blog</b></a><a class="navbar__item navbar__link" href="/docs/intro">读书笔记</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/kayhaw" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle toggle_3Zt9 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper blog-wrapper blog-post-page"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_2ahu thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_2hhb margin-bottom--md">Recent posts</div><ul class="sidebarItemList_2xAf"><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/2022/02/20/Learning-Hive3.x-02">Hive 3.x学习笔记(2)</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/2022/02/19/Learning-Hive3.x-01">Hive 3.x学习笔记(1)</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/2022/02/19/WorkJournal">2022年2月份工作总结</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/2022/02/15/NetworkingSummary-01">计算机网络知识总结(1)</a></li><li class="sidebarItem_2UVv"><a aria-current="page" class="sidebarItemLink_1RT6 sidebarItemLinkActive_12pM" href="/blog/2022/02/10/Learning-Hadoop3.x-06">Hadoop 3.x学习笔记(6)</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="blogPostTitle_GeHD" itemprop="headline">Hadoop 3.x学习笔记(6)</h1><div class="blogPostData_291c margin-vert--md"><time datetime="2022-02-10T00:00:00.000Z" itemprop="datePublished">February 10, 2022</time> · 3 min read</div><div class="row margin-top--md margin-bottom--sm"><div class="col col--6 authorCol_1R69"><div class="avatar margin-bottom--sm"><a href="https://github.com/kayhaw" target="_blank" rel="noopener noreferrer" class="avatar__photo-link avatar__photo"><img class="image_1yU8" src="https://avatars.githubusercontent.com/u/16892835?v=4" alt="何轲"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/kayhaw" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">何轲</span></a></div><small class="avatar__subtitle" itemprop="description">Never settle down</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><p>📝Hadoop 3.1.3学习笔记第6篇：源码分析。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="namenode启动源码分析"></a>NameNode启动源码分析<a class="hash-link" href="#namenode启动源码分析" title="Direct link to heading">#</a></h2><p>分析NameNode.java(在hadoop-hdfs.jar包下)，主要有以下流程：启动Web服务、加载镜像文件和编辑日志、初始化RPC服务器、启动资源检查、心跳检测和安全模式。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="启动web服务"></a>启动Web服务<a class="hash-link" href="#启动web服务" title="Direct link to heading">#</a></h3><p>从NameNode.java的main() -&gt; createNameNode -&gt; NameNode构造方法 -&gt; initialize -&gt; <strong>startHttpServer</strong>方法启动NameNode服务。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">private void startHttpServer(final Configuration conf) throws IOException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    httpServer = new NameNodeHttpServer(conf, this, getHttpServerBindAddress(conf));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    httpServer.start();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    httpServer.setStartupProgress(startupProgress);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">protected InetSocketAddress getHttpServerBindAddress(Configuration conf) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    InetSocketAddress bindAddress = getHttpServerAddress(conf);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // If DFS_NAMENODE_HTTP_BIND_HOST_KEY exists then it overrides the</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // host name portion of DFS_NAMENODE_HTTP_ADDRESS_KEY.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    final String bindHost = conf.getTrimmed(DFS_NAMENODE_HTTP_BIND_HOST_KEY);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (bindHost != null &amp;&amp; !bindHost.isEmpty()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      bindAddress = new InetSocketAddress(bindHost, bindAddress.getPort());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return bindAddress;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>其中getHttpServerBindAddress从conf获取<code>dfs.namenode.http-address</code>来设置服务的地址和端口号，若没有设置则默认为<code>0.0.0.0:9870</code>；接着判断是否配置<code>dfs.namenode.http-bind-host</code>，若有设置则用其作为服务地址。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="加载镜像文件和编辑文件"></a>加载镜像文件和编辑文件<a class="hash-link" href="#加载镜像文件和编辑文件" title="Direct link to heading">#</a></h3><p>NameNode.java的loadNameSystem方法，又调用FSNamesystem.loadFromDisk方法，注意加载传入镜像文件和编辑文件两个地址。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">static FSNamesystem loadFromDisk(Configuration conf) throws IOException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    checkConfiguration(conf);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    FSImage fsImage = new FSImage(conf,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        FSNamesystem.getNamespaceDirs(conf),</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        FSNamesystem.getNamespaceEditsDirs(conf));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="创建rpc服务"></a>创建RPC服务<a class="hash-link" href="#创建rpc服务" title="Direct link to heading">#</a></h3><p>initialize方法调用createRpcServer方法，创建一个NameNodeRpcServer对象，其构造方法包含如下代码来创建Rpc服务器。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">lifelineRpcServer = new RPC.Builder(conf)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    .setProtocol(HAServiceProtocolPB.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    .setInstance(haPbService)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    .setBindAddress(bindHost)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    .setPort(lifelineRpcAddr.getPort())</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    .setNumHandlers(lifelineHandlerCount)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    .setVerbose(false)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    .setSecretManager(namesystem.getDelegationTokenSecretManager())</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    .build();</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="资源检测"></a>资源检测<a class="hash-link" href="#资源检测" title="Direct link to heading">#</a></h3><p>initialize方法调用startCommonServices方法，调用FSNamesystem的startCommonServices方法，该方法包含操作：</p><ol><li>创建NameNodeResourceChecker对象，检查元数据存储空间是否剩余100MB可用</li><li>checkAvailableResources-&gt;hasAvailableDiskSpace-&gt;areResourcesAvailable-&gt;isResourceAvailable，检查资源是否剩余100MB空间</li></ol><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="心跳检测"></a>心跳检测<a class="hash-link" href="#心跳检测" title="Direct link to heading">#</a></h3><p>startCommonServices通过blockManager.activate-&gt;datanodeManager.activate(conf)-&gt;heartbeatManager.activate()-&gt;heartbeatThread.start()-&gt;Monitor.run()-&gt;heartbeatCheck()-&gt;isDatanodeDead()，判断节点是否挂掉的心跳时长<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>e</mi><mi>a</mi><mi>r</mi><mi>t</mi><mi>b</mi><mi>e</mi><mi>a</mi><mi>t</mi><mi>E</mi><mi>x</mi><mi>p</mi><mi>i</mi><mi>r</mi><mi>e</mi><mi>I</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>v</mi><mi>a</mi><mi>l</mi><mo>=</mo><mn>2</mn><mo>∗</mo><mi>h</mi><mi>e</mi><mi>a</mi><mi>r</mi><mi>t</mi><mi>b</mi><mi>e</mi><mi>a</mi><mi>t</mi><mi>R</mi><mi>e</mi><mi>c</mi><mi>h</mi><mi>e</mi><mi>c</mi><mi>k</mi><mi>I</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>v</mi><mi>a</mi><mi>l</mi><mo>+</mo><mn>10</mn><mo>∗</mo><mn>1000</mn><mo>∗</mo><mi>h</mi><mi>e</mi><mi>a</mi><mi>r</mi><mi>t</mi><mi>b</mi><mi>e</mi><mi>a</mi><mi>t</mi><mi>I</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>v</mi><mi>a</mi><mi>l</mi><mi>S</mi><mi>e</mi><mi>c</mi><mi>o</mi><mi>n</mi><mi>d</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">heartbeatExpireInterval=2*heartbeatRecheckInterval+10*1000*heartbeatIntervalSeconds</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em">r</span><span class="mord mathnormal">t</span><span class="mord mathnormal">b</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.05764em">E</span><span class="mord mathnormal">x</span><span class="mord mathnormal">p</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.02778em">r</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.07847em">I</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02778em">r</span><span class="mord mathnormal" style="margin-right:0.03588em">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em">l</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em">r</span><span class="mord mathnormal">t</span><span class="mord mathnormal">b</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.00773em">R</span><span class="mord mathnormal">e</span><span class="mord mathnormal">c</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.03148em">k</span><span class="mord mathnormal" style="margin-right:0.07847em">I</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02778em">r</span><span class="mord mathnormal" style="margin-right:0.03588em">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em">l</span><span class="mspace" style="margin-right:0.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em"></span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em">r</span><span class="mord mathnormal">t</span><span class="mord mathnormal">b</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.07847em">I</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02778em">r</span><span class="mord mathnormal" style="margin-right:0.03588em">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em">l</span><span class="mord mathnormal" style="margin-right:0.05764em">S</span><span class="mord mathnormal">e</span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mord mathnormal">s</span></span></span></span></span>，其中<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>e</mi><mi>a</mi><mi>r</mi><mi>t</mi><mi>b</mi><mi>e</mi><mi>a</mi><mi>t</mi><mi>R</mi><mi>e</mi><mi>c</mi><mi>h</mi><mi>e</mi><mi>c</mi><mi>k</mi><mi>I</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>v</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">heartbeatRecheckInterval</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em">r</span><span class="mord mathnormal">t</span><span class="mord mathnormal">b</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.00773em">R</span><span class="mord mathnormal">e</span><span class="mord mathnormal">c</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.03148em">k</span><span class="mord mathnormal" style="margin-right:0.07847em">I</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02778em">r</span><span class="mord mathnormal" style="margin-right:0.03588em">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em">l</span></span></span></span></span>默认为5分钟，<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>e</mi><mi>a</mi><mi>r</mi><mi>t</mi><mi>b</mi><mi>e</mi><mi>a</mi><mi>t</mi><mi>I</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>v</mi><mi>a</mi><mi>l</mi><mi>S</mi><mi>e</mi><mi>c</mi><mi>o</mi><mi>n</mi><mi>d</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">heartbeatIntervalSeconds</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em">r</span><span class="mord mathnormal">t</span><span class="mord mathnormal">b</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.07847em">I</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02778em">r</span><span class="mord mathnormal" style="margin-right:0.03588em">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em">l</span><span class="mord mathnormal" style="margin-right:0.05764em">S</span><span class="mord mathnormal">e</span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mord mathnormal">s</span></span></span></span></span>默认为3，即判断节点是否挂掉的心跳时长默认为10分钟加30秒。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="安全模式开启"></a>安全模式开启<a class="hash-link" href="#安全模式开启" title="Direct link to heading">#</a></h3><p>FSNamesystem的startCommonServices方法调用blockManager.activate-&gt;bmSafeMode.activate(blockTotal)，代码如下所示，调用setBlockTotal方法设置所有块的总数和安全阈值，调用areThresholdsMet判断是否满足可用阈值，相应的设置是否进入安全模式。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">void activate(long total) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  assert namesystem.hasWriteLock();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  assert status == BMSafeModeStatus.OFF;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  startTime = monotonicNow();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  setBlockTotal(total);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (areThresholdsMet()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    boolean exitResult = leaveSafeMode(false);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Preconditions.checkState(exitResult, &quot;Failed to leave safe mode.&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // enter safe mode</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    status = BMSafeModeStatus.PENDING_THRESHOLD;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    initializeReplQueuesIfNecessary();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    reportStatus(&quot;STATE* Safe mode ON.&quot;, true);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    lastStatusReport = monotonicNow();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="datanode启动源码分析"></a>DataNode启动源码分析<a class="hash-link" href="#datanode启动源码分析" title="Direct link to heading">#</a></h2><p>DataNode启动后，首先向NameNode注册自己，然后定期(6小时)向NN上报所有块信息，每隔3秒向NN发送心跳，如果NN超过10分30秒没有收到DataNode心跳则认为该节点不可用。启动流程如下：</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="初始化dataxceiverserver"></a>初始化DataXceiverServer<a class="hash-link" href="#初始化dataxceiverserver" title="Direct link to heading">#</a></h3><p>以DataNode.java的main方法为入口：secureMain-&gt;createDataNode-&gt;instantiateDataNode-&gt;makeInstance-&gt;new DataNode-&gt;startDataNode-&gt;initDataXceiver，调用<code>this.dataXceiverServer = new Daemon(threadGroup, xserver);</code>开启服务线程。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="初始化http服务"></a>初始化HTTP服务<a class="hash-link" href="#初始化http服务" title="Direct link to heading">#</a></h3><p>startDataNode方法调用startInfoServer为入口：new DatanodeHttpServer-&gt;new HttpServer2，然后开启http服务，提供访问DataNode信息的endpoint。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="初始化rpc服务"></a>初始化Rpc服务<a class="hash-link" href="#初始化rpc服务" title="Direct link to heading">#</a></h3><p>startDataNode方法调用initIpcServer为入口，创建RPC对象。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="向namenode注册"></a>向NameNode注册<a class="hash-link" href="#向namenode注册" title="Direct link to heading">#</a></h3><p>startDataNode方法调用BlockPoolManager.refreshNamenodes方法为入口：doRefreshNamenodes-&gt;createBPOS-&gt;new BPOfferService-&gt;new BPServiceActor，有多少个NameNode就添加多少个BPServiceActor，在调用createBPOS后，调用startAll方法进入注册：bpos.start()-&gt;actor.start()-&gt;BPServiceActor.run()-&gt;connectToNNAndHandshake()-&gt;db.connectToNN()-&gt;new DatanodeProtocolClientSideTranslatorPB()-&gt;createNamenode()-&gt;RPC.getProxy()，最终得到代理对象。然后开始注册DataNode信息：register()-&gt;bpNamenode.registerDatanode(newBpRegistration)-&gt;rpcProxy.registerDatanode()，通过rpc调用<strong>NameNode</strong>的registerDatanode方法。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="发送心跳"></a>发送心跳<a class="hash-link" href="#发送心跳" title="Direct link to heading">#</a></h3><p>回到BPServiceActor.run()方法，调用offerService为入口：sendHeartBeat-&gt;bpNamenode.sendHeartbeat-&gt;NameNodeRpcServer.sendHeartbeat-&gt;namesystem.handleHeartbeat-&gt;blockManager.getDatanodeManager().handleHeartbeat-&gt;heartbeatManager.updateHeartbeat-&gt;blockManager.updateHeartbeat-&gt;node.updateHeartbeat-&gt;updateHeartbeatState，由NameNode返回一个HeartbeatResponse对象作为心跳响应。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">void updateHeartbeatState(StorageReport[] reports, long cacheCapacity,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    long cacheUsed, int xceiverCount, int volFailures,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    VolumeFailureSummary volumeFailureSummary) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  updateStorageStats(reports, cacheCapacity, cacheUsed, xceiverCount,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      volFailures, volumeFailureSummary);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  setLastUpdate(Time.now());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  setLastUpdateMonotonic(Time.monotonicNow());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  rollBlocksScheduled(getLastUpdateMonotonic());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="hdfs文件上传源码分析"></a>HDFS文件上传源码分析<a class="hash-link" href="#hdfs文件上传源码分析" title="Direct link to heading">#</a></h2><p>第一部分：新增文件元信息。以FileSystem.create(Path path, boolean overwrite)方法为入口，调用抽象方法create-&gt;DistributedFileSystem.create()-&gt;dfs.create-&gt;DFSOutputStream.newStreamForCreate-&gt;dfsClient.namenode.create(调用客户端的Rpc创建方法)-&gt;namesystem.startFile()[NameNodeRpcServer.java, Line 791]-&gt;startFileInt(FSNamesystem.java, Line 2375)-&gt;FSDirWriteFileOp.startFile-&gt;FSDirWriteFileOp.addFile-&gt;fsd.addINode(Line 568)，最后通过addINode方法将路径添加到文件系统元信息中。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public void testPut2() throws IOException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    FSDataOutputStream fos = fs.create(new Path(&quot;/input2&quot;));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    fos.write(&quot;hello world&quot;.getBytes());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>回到DFSOutputStream.java的276行，在添加完文件元信息后，在313行创建文件输出流DFSOutputStream对象out，该类的构造方法调用了如下computePacketChunkSize方法来计算Packet包含的chunk数量和packet的大小：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">protected void computePacketChunkSize(int psize, int csize) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  final int bodySize = psize - PacketHeader.PKT_MAX_HEADER_LEN;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  final int chunkSize = csize + getChecksumSize();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  chunksPerPacket = Math.max(bodySize/chunkSize, 1);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  packetSize = chunkSize*chunksPerPacket;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  DFSClient.LOG.debug(&quot;computePacketChunkSize: src={}, chunkSize={}, &quot;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          + &quot;chunksPerPacket={}, packetSize={}&quot;,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      src, chunkSize, chunksPerPacket, packetSize);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>默认Packet大小为64KB，chunk大小为512Byte，chunksum大小为4Byte。创建完out对象后，接着调用其start方法：DataStreamer.start()-&gt;DataStreamer.run()-&gt;dataQueue.wait()。其中dataQueue是<code>LinkedList&lt;DFSPacket&gt;</code>类型对象，调用wait方法阻塞队列直到有packet入队。</p><p>第二部分：写数据。第一步是写packet，以FSDataOutputStream.write方法为入口：FilterOutputStream.write-&gt;FSOutputSummer.write-&gt;FSOutputSummer.flushBuffer-&gt;FSOutputSummer.writeChecksumChunks-&gt;DFSOutputStream.writeChunk-&gt;DFSOutputStream.enqueueCurrentPacketFull-&gt;DFSOutputStream.enqueueCurrentPacket-&gt;DataStreamer.waitAndQueuePacket，第一次写数据队列为空，因此接下来调用queuePacket方法，代码如下所有，它将packet添加在队列末尾，然后调用notifyAll唤醒所有阻塞线程。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">void queuePacket(DFSPacket packet) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  synchronized (dataQueue) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (packet == null) return;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    packet.addTraceParent(Tracer.getCurrentSpanId());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    dataQueue.addLast(packet);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    lastQueuedSeqno = packet.getSeqno();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    LOG.debug(&quot;Queued {}, {}&quot;, packet, this);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    dataQueue.notifyAll();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>第二步，建立数据传输管理pipeline。回到DataStreamer的run方法，以setPipeline方法为入口：DataStreamer.nextBlockOutputStream-&gt;DataStreamer.locateFollowingBlock-&gt;DFSOutputStream.addBlock-&gt;dfsClient.namenode.addBlock(NameNodeRpcServer.addBlock)-&gt;FSNamesystem.getAdditionalBlock-&gt;FSDirWriteFileOp.chooseTargetForNewBlock-&gt;BlockManager.chooseTarget4NewBlock-&gt;BlockPlacementPolicyDefault.chooseTarget-&gt;BlockPlacementPolicyDefault.chooseTargetInOrder-&gt;</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">protected Node chooseTargetInOrder(int numOfReplicas, </span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                 Node writer,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                 final Set&lt;Node&gt; excludedNodes,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                 final long blocksize,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                 final int maxNodesPerRack,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                 final List&lt;DatanodeStorageInfo&gt; results,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                 final boolean avoidStaleNodes,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                 final boolean newBlock,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                 EnumMap&lt;StorageType, Integer&gt; storageTypes)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                 throws NotEnoughReplicasException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  final int numOfResults = results.size();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (numOfResults == 0) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    DatanodeStorageInfo storageInfo = chooseLocalStorage(writer,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        excludedNodes, blocksize, maxNodesPerRack, results, avoidStaleNodes,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        storageTypes, true);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    writer = (storageInfo != null) ? storageInfo.getDatanodeDescriptor()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    : null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (--numOfReplicas == 0) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      return writer;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  final DatanodeDescriptor dn0 = results.get(0).getDatanodeDescriptor();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (numOfResults &lt;= 1) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    chooseRemoteRack(1, dn0, excludedNodes, blocksize, maxNodesPerRack,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        results, avoidStaleNodes, storageTypes);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (--numOfReplicas == 0) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      return writer;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (numOfResults &lt;= 2) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    final DatanodeDescriptor dn1 = results.get(1).getDatanodeDescriptor();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (clusterMap.isOnSameRack(dn0, dn1)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      chooseRemoteRack(1, dn0, excludedNodes, blocksize, maxNodesPerRack,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          results, avoidStaleNodes, storageTypes);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else if (newBlock){</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      chooseLocalRack(dn1, excludedNodes, blocksize, maxNodesPerRack,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          results, avoidStaleNodes, storageTypes);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      chooseLocalRack(writer, excludedNodes, blocksize, maxNodesPerRack,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          results, avoidStaleNodes, storageTypes);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (--numOfReplicas == 0) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      return writer;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  chooseRandom(numOfReplicas, NodeBase.ROOT, excludedNodes, blocksize,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      maxNodesPerRack, results, avoidStaleNodes, storageTypes);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  return writer;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>回到DataStreamer.nextBlockOutputStream方法，在调用locateFollowingBlock后得到上传节点的位置信息后，接着以createBlockOutputStream方法为入口：new Sender(out).writeBlock-&gt;Sender.send(out, Op.WRITE_BLOCK, proto.build()发送数据。对应地，DataXceiverServer的run方法执行DataXceiver的run方法，根据发送端的op类型调用processOp进行处理。由于发送端op类型为WRITE_BLOCK，调用Receiver.opWriteBlock(DataInputStream in)方法，继而调用DataXceiver.writeBlock方法：首先通过setCurrentBlockReceiver写块文件，然后判断目标节点个数是否大于0，是的话又用new Sender(mirrorOut).writeBlock写数据（触发写下一个节点的链式调用）。</p><p>回到DataStreamer的run方法，在717行调用setPipeline后，接着调用initDataStreaming方法，通过ResponseProcessor线程对象处理写成功响应。</p><div class="codeBlockContainer_K1bP"><div style="color:#393A34;background-color:#f6f8fa" class="codeBlockTitle_eoMF">ResponseProcessor.run(), Line 1179-1183</div><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">lastAckedSeqno = seqno;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">pipelineRecoveryCount = 0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">ackQueue.removeFirst();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">packetSendTime.remove(seqno);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">dataQueue.notifyAll();</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>在发送packet后，不会将该packet删除而是添加到ackQueue中，代码如下所示：</p><div class="codeBlockContainer_K1bP"><div style="color:#393A34;background-color:#f6f8fa" class="codeBlockTitle_eoMF">DataStreamer.run(), Line 753-767</div><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">synchronized (dataQueue) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // move packet from dataQueue to ackQueue</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (!one.isHeartbeatPacket()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (scope != null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      spanId = scope.getSpanId();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      scope.detach();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      one.setTraceScope(scope);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    scope = null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    dataQueue.removeFirst();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ackQueue.addLast(one);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    packetSendTime.put(one.getSeqno(), Time.monotonicNow());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    dataQueue.notifyAll();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="yarn工作机制"></a>Yarn工作机制<a class="hash-link" href="#yarn工作机制" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="任务提交"></a>任务提交<a class="hash-link" href="#任务提交" title="Direct link to heading">#</a></h3><p>Job.waitForCompletion为入口：Job.submit-&gt;submitter.submitJobInternal-&gt;submitClient.submitJob-&gt;YARNRunner.submitJob，该方法有2个主要方法调用：createApplicationSubmissionContext和submitApplication。先看创建应用执行环境方法：它会调用setupAMCommand方法构建App master的启动命令，该方法设置一堆java启动参数后，设置启动类为<code>org.apache.hadoop.mapreduce.v2.app.MRAppMaster</code>，并将标准输出和标准错误重定向到对应文件夹，代码如下所示：</p><div class="codeBlockContainer_K1bP"><div style="color:#393A34;background-color:#f6f8fa" class="codeBlockTitle_eoMF">YARNRunner.java, Line 498-502</div><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">vargs.add(MRJobConfig.APPLICATION_MASTER_CLASS);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">vargs.add(&quot;1&gt;&quot; + ApplicationConstants.LOG_DIR_EXPANSION_VAR +</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Path.SEPARATOR + ApplicationConstants.STDOUT);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">vargs.add(&quot;2&gt;&quot; + ApplicationConstants.LOG_DIR_EXPANSION_VAR +</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Path.SEPARATOR + ApplicationConstants.STDERR);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>在创建好应用提交上下文环境对象appContext后，接着调用submitApplication提交，该方法进而调用YarnClinetImpl.submitApplication方法，该方法又调用ClientRMService.submitApplication方法(到了ResourceManager服务)，将提交上下文信息插入到队列中。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="mrappmaster启动"></a>MRAppMaster启动<a class="hash-link" href="#mrappmaster启动" title="Direct link to heading">#</a></h3><p>将任务信息插入到队列后，由MRAppMaster来获取队列任务并安排执行。以MRAppMaster.main方法为入口：initAndStartAppMaster-&gt;init-&gt;serviceInit-&gt;createDispatcher创建调度器。在init方法后调用start方法启动服务：serviceStart-&gt;startJobs-&gt;dispatcher.getEventHandler().handle(startJobEvent)-&gt;GenericEventHandler.eventQueue.put(event)，将任务提交到运行队列。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="yarnchild执行任务"></a>YarnChild执行任务<a class="hash-link" href="#yarnchild执行任务" title="Direct link to heading">#</a></h3><p>YarnChild是MRAppMaster中执行任务的封装，以其main方法为入口：Task.run-&gt;MapTask.run/ReduceTask.run。以MapTaskRun为例，调用runNewMapper-&gt;mapper.run-&gt;自定义Mapper.run。</p></div><footer class="row docusaurus-mt-lg blogPostDetailsFull_3kfx"><div class="col"><b>Tags:</b><ul class="tags_2ga9 padding--none margin-left--sm"><li class="tag_11ep"><a class="tag_1Okp tagRegular_3MiF" href="/blog/tags/hadoop">Hadoop</a></li><li class="tag_11ep"><a class="tag_1Okp tagRegular_3MiF" href="/blog/tags/big-data">BigData</a></li></ul></div><div class="col margin-top--sm"><a href="https://github.com/kayhaw/kayhaw.github.io/edit/master/website/blog/blog/2022-02-10-Learning-Hadoop3.x-06.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/blog/2022/02/15/NetworkingSummary-01"><div class="pagination-nav__sublabel">Newer Post</div><div class="pagination-nav__label">« 计算机网络知识总结(1)</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/blog/2022/02/07/Learning-Hadoop3.x-04"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">Hadoop 3.x学习笔记(4) »</div></a></div></nav></main><div class="col col--2"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#namenode启动源码分析" class="table-of-contents__link">NameNode启动源码分析</a><ul><li><a href="#启动web服务" class="table-of-contents__link">启动Web服务</a></li><li><a href="#加载镜像文件和编辑文件" class="table-of-contents__link">加载镜像文件和编辑文件</a></li><li><a href="#创建rpc服务" class="table-of-contents__link">创建RPC服务</a></li><li><a href="#资源检测" class="table-of-contents__link">资源检测</a></li><li><a href="#心跳检测" class="table-of-contents__link">心跳检测</a></li><li><a href="#安全模式开启" class="table-of-contents__link">安全模式开启</a></li></ul></li><li><a href="#datanode启动源码分析" class="table-of-contents__link">DataNode启动源码分析</a><ul><li><a href="#初始化dataxceiverserver" class="table-of-contents__link">初始化DataXceiverServer</a></li><li><a href="#初始化http服务" class="table-of-contents__link">初始化HTTP服务</a></li><li><a href="#初始化rpc服务" class="table-of-contents__link">初始化Rpc服务</a></li><li><a href="#向namenode注册" class="table-of-contents__link">向NameNode注册</a></li><li><a href="#发送心跳" class="table-of-contents__link">发送心跳</a></li></ul></li><li><a href="#hdfs文件上传源码分析" class="table-of-contents__link">HDFS文件上传源码分析</a></li><li><a href="#yarn工作机制" class="table-of-contents__link">Yarn工作机制</a><ul><li><a href="#任务提交" class="table-of-contents__link">任务提交</a></li><li><a href="#mrappmaster启动" class="table-of-contents__link">MRAppMaster启动</a></li><li><a href="#yarnchild执行任务" class="table-of-contents__link">YarnChild执行任务</a></li></ul></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">读书笔记</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items"><li class="footer__item"><a href="https://www.zhihu.com/people/xiao-ke-dou-7" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>知乎<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/kayhaw" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://gitee.com/kayhaw" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Gitee<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 何轲(Kay Haw). Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.5c7121e2.js"></script>
<script src="/assets/js/main.eedec005.js"></script>
</body>
</html>