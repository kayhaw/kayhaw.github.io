<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.6">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Kay Haw&#39;s Blog Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Kay Haw&#39;s Blog Blog Atom Feed">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" integrity="sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc" crossorigin="anonymous"><title data-react-helmet="true">FlinkX源码剖析(1) | Kay Haw&#x27;s Blog</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://kayhaw.github.io/blog/2022/01/09/FlinkX-Source-Code-Dissection-01"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_tag" content="default"><meta data-react-helmet="true" property="og:title" content="FlinkX源码剖析(1) | Kay Haw&#x27;s Blog"><meta data-react-helmet="true" name="description" content="FlinkX源码剖析(1)"><meta data-react-helmet="true" property="og:description" content="FlinkX源码剖析(1)"><meta data-react-helmet="true" property="og:type" content="article"><meta data-react-helmet="true" property="article:published_time" content="2022-01-09T00:00:00.000Z"><meta data-react-helmet="true" property="article:author" content="https://github.com/kayhaw"><meta data-react-helmet="true" property="article:tag" content="FlinkX,Source code dissection"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://kayhaw.github.io/blog/2022/01/09/FlinkX-Source-Code-Dissection-01"><link data-react-helmet="true" rel="alternate" href="https://kayhaw.github.io/blog/2022/01/09/FlinkX-Source-Code-Dissection-01" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://kayhaw.github.io/blog/2022/01/09/FlinkX-Source-Code-Dissection-01" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.0138175c.css">
<link rel="preload" href="/assets/js/runtime~main.5c7121e2.js" as="script">
<link rel="preload" href="/assets/js/main.eedec005.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="Kay Haw&#x27;s Blog" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo.svg" alt="Kay Haw&#x27;s Blog" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">Kay Haw&#x27;s Blog</b></a><a class="navbar__item navbar__link" href="/docs/intro">读书笔记</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/kayhaw" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle toggle_3Zt9 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper blog-wrapper blog-post-page"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_2ahu thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_2hhb margin-bottom--md">Recent posts</div><ul class="sidebarItemList_2xAf"><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/2022/02/20/Learning-Hive3.x-02">Hive 3.x学习笔记(2)</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/2022/02/19/Learning-Hive3.x-01">Hive 3.x学习笔记(1)</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/2022/02/19/WorkJournal">2022年2月份工作总结</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/2022/02/15/NetworkingSummary-01">计算机网络知识总结(1)</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/2022/02/10/Learning-Hadoop3.x-06">Hadoop 3.x学习笔记(6)</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="blogPostTitle_GeHD" itemprop="headline">FlinkX源码剖析(1)</h1><div class="blogPostData_291c margin-vert--md"><time datetime="2022-01-09T00:00:00.000Z" itemprop="datePublished">January 9, 2022</time> · 4 min read</div><div class="row margin-top--md margin-bottom--sm"><div class="col col--6 authorCol_1R69"><div class="avatar margin-bottom--sm"><a href="https://github.com/kayhaw" target="_blank" rel="noopener noreferrer" class="avatar__photo-link avatar__photo"><img class="image_1yU8" src="https://avatars.githubusercontent.com/u/16892835?v=4" alt="何轲"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/kayhaw" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">何轲</span></a></div><small class="avatar__subtitle" itemprop="description">Never settle down</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><p>📝FlinkX源码剖析(1)：主流程分析。以local模式运行为例分析FlinkX主流程执行逻辑：从运行脚本开始到配置参数的解析、<strong>插件类加载</strong>，最后到Flink流应用构建执行。代码注释见<a href="https://github.com/kayhaw/flinkx/tree/1.12_release_dissection" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/badge/flinkx-1.12__release__dissection-blue" alt="FlinkX Dissection"></a>。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="启动脚本"></a>启动脚本<a class="hash-link" href="#启动脚本" title="Direct link to heading">#</a></h2><p>FlinkX提供了<code>bin/flinkx</code>脚本用于在命令行快速启动同步任务，它本质上就是一个java命令的封装，但还是要展开来仔细地讲讲它用到的一些bash知识。</p><p>首先第一行<code>set -e</code>，作用是让脚本执行错误时立即退出，因为默认情况下执行命令错误后会继续执行，建议在所有脚本头部都加上。接下来这个设置环境变量的代码就很😏了：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly bash"><pre tabindex="0" class="prism-code language-bash codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token builtin class-name">export</span><span class="token plain"> </span><span class="token assign-left variable" style="color:#36acaa">FLINKX_HOME</span><span class="token operator" style="color:#393A34">=</span><span class="token string" style="color:#e3116c">&quot;</span><span class="token string variable" style="color:#36acaa">$(</span><span class="token string variable builtin class-name" style="color:#36acaa">cd</span><span class="token string variable" style="color:#36acaa"> </span><span class="token string variable string" style="color:#e3116c">&quot;</span><span class="token string variable string variable" style="color:#36acaa">`</span><span class="token string variable string variable function" style="color:#d73a49">dirname</span><span class="token string variable string variable" style="color:#36acaa"> </span><span class="token string variable string variable string" style="color:#e3116c">&quot;</span><span class="token string variable string variable string variable" style="color:#36acaa">$0</span><span class="token string variable string variable string" style="color:#e3116c">&quot;</span><span class="token string variable string variable" style="color:#36acaa">`</span><span class="token string variable string" style="color:#e3116c">&quot;</span><span class="token string variable" style="color:#36acaa">/</span><span class="token string variable punctuation" style="color:#393A34">..</span><span class="token string variable punctuation" style="color:#393A34">;</span><span class="token string variable" style="color:#36acaa"> </span><span class="token string variable builtin class-name" style="color:#36acaa">pwd</span><span class="token string variable" style="color:#36acaa">)</span><span class="token string" style="color:#e3116c">&quot;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>从外到内分析，使用<code>$()</code>执行2条命令<code>cd &quot;`dirname &quot;$0&quot;`&quot;/..</code>和<code>pwd</code>。第一条cd命令的参数又由命令<code>`dirname &quot;$0&quot;`</code>给出，<code>dirname</code>是bash内置命令，输出后面参数文件所在的目录路径，而参数<code>&quot;$0&quot;</code>表示脚本文件<code>flinkx</code>。结合起来的含义就是切换到flinkx这个脚本文件所在的父目录bin下，然后再切换到上一层目录到项目目录，最后打印绝对路径，即设置用户变量FLINKX_HOME为项目文件夹的绝对路径。</p><ul class="contains-task-list"><li class="task-list-item"><input type="checkbox" disabled=""> set、env、export的区别</li></ul><p>接下来看当前系统能不能使用java程序，先看<code>JAVA_HOME</code>环境是否存在，若不存在再用<code>command -v java</code>看能不能直接执行java程序，再没有就报错退出。接下来设置两个shell变量<code>JAR_DIR</code>和入口类名<code>CLASS_NAME</code>，然后执行命令：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly bash"><pre tabindex="0" class="prism-code language-bash codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token function" style="color:#d73a49">nohup</span><span class="token plain"> </span><span class="token variable" style="color:#36acaa">$JAVA_RUN</span><span class="token plain"> -cp </span><span class="token variable" style="color:#36acaa">$JAR_DIR</span><span class="token plain"> </span><span class="token variable" style="color:#36acaa">$CLASS_NAME</span><span class="token plain"> </span><span class="token variable" style="color:#36acaa">$@</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">&amp;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>nohup命令是no hang up命令的缩写，它将后面跟着的命令挂到后台运行并将输出重定向到nohup.out文件，通常跟<code>&amp;</code>搭配使用，让命令执行同时忽略SIGINT和SIGHUP信号。变量替换后的命令如下，<code>$@</code>表示执行flinkx脚本后面跟着的所有参数。</p><ul class="contains-task-list"><li class="task-list-item"><input type="checkbox" disabled=""> nohup和&amp;的区别</li><li class="task-list-item"><input type="checkbox" disabled=""> <code>$@</code>，<code>$#</code>，<code>$1</code>...<code>$n</code>的含义</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly bash"><pre tabindex="0" class="prism-code language-bash codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">java -cp /path-to-flinkx/lib/* com.dtstack.flinkx.client.Launcher </span><span class="token variable" style="color:#36acaa">$@</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>以运行一个MySQL到Hive的同步任务为例，在Linux执行命令如下：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly bash"><pre tabindex="0" class="prism-code language-bash codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">bin/flinkx -mode </span><span class="token builtin class-name">local</span><span class="token plain">   </span><span class="token punctuation" style="color:#393A34">\</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">         -jobType </span><span class="token function" style="color:#d73a49">sync</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">\</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">         -jobName test_kayhaw </span><span class="token punctuation" style="color:#393A34">\</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">         -job E:</span><span class="token punctuation" style="color:#393A34">\</span><span class="token plain">flinkx_job</span><span class="token punctuation" style="color:#393A34">\</span><span class="token plain">new_mysql_hive.json </span><span class="token punctuation" style="color:#393A34">\</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">         -flinkxDistDir E:</span><span class="token punctuation" style="color:#393A34">\</span><span class="token plain">flinkx</span><span class="token punctuation" style="color:#393A34">\</span><span class="token plain">flinkx-dist </span><span class="token punctuation" style="color:#393A34">\</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>在IEDA运行FlinkX同步任务配置运行参数命令如下图所示，其中Program arguments内容即上述命令参数内容。</p><img style="width:100%;height:100%" src="/img/blog/FlinkXDissection/FlinkX_IDEA_RunConfig.png" title="FlinkX IDEA Run Configuration"><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="命令行入口launcher"></a>命令行入口Launcher<a class="hash-link" href="#命令行入口launcher" title="Direct link to heading">#</a></h2><p>从<code>bin/flinx</code>脚本得知该命令行运行入口为Launcher类，它位于flinkx-clients模块，接下来对其main方法展开分析。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="参数解析"></a>参数解析<a class="hash-link" href="#参数解析" title="Direct link to heading">#</a></h3><p>首先对命令后面的一大坨参数进行解析，借助于Apache Commons CLI包来完成。为了将参数字符串转为<code>com.dtstack.flinkx.options.Options</code>对象，使用反射获取Options的字段，结合Common CLI提供的<code>DefaultParser.parse()</code>方法将字符串转为CommandLine对象，然后再遍历Options的字段名称name，通过<code>CommandLine.getOptionValue(name)</code>获取参数值，最后设置回给Options对象。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="默认参数配置"></a>默认参数配置<a class="hash-link" href="#默认参数配置" title="Direct link to heading">#</a></h3><p>接下来findDefaultConfigDir()方法用于在命令行没有提供的情况下，设置3个文件夹路径参数默认值，分别是FlinkX读写插件包文件夹、Flink配置文件夹和Hadoop配置文件夹：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">private static void findDefaultConfigDir(Options launcherOptions) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    findDefaultFlinkxDistDir(launcherOptions);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // local模式只需要配置FlinkXDistDir这一个就可以</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ClusterMode.local.name().equalsIgnoreCase(launcherOptions.getMode())) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    findDefaultFlinkConf(launcherOptions);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    findDefaultHadoopConf(launcherOptions);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>以findDefaultFlinkxDistDir()代码为例：当命令行参数没有flinkDistDir时，看环境变量中有没有配置<code>FLINX_HOME</code>，这个查看环境变量方法getSystemProperty()也有讲究，先调用System.getenv()看有没有，没有再看System.getProperty()。如果有环境变量<code>FLINKX_HOME</code>，根据它设置flinkx插件包路径，并注册为环境变量<code>ConfigConstants.ENV_FLINK_PLUGINS_DIR</code>。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">private static void findDefaultFlinkxDistDir(Options launcherOptions) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    String distDir = launcherOptions.getFlinkxDistDir();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果运行参数还未设置，通过系统变量来自己找</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (StringUtils.isEmpty(distDir)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String flinkxHome = getSystemProperty(KEY_FLINKX_HOME);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (StringUtils.isNotEmpty(flinkxHome)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            flinkxHome = flinkxHome.trim();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 还考虑到路径最末尾有没有加路径分隔符，细！</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (flinkxHome.endsWith(File.separator)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                distDir = flinkxHome + PLUGINS_DIR_NAME;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                distDir = flinkxHome + File.separator + PLUGINS_DIR_NAME;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            launcherOptions.setFlinkxDistDir(distDir);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.setProperty(ConfigConstants.ENV_FLINK_PLUGINS_DIR, distDir);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>findDefaultFlinkConf()方法在有环境变量FLIN<strong>K</strong>_HOME设置的情况下，补充设置Flink的conf目录和lib目录参数。findDefaultHadoopConf()方法类似查看HADOOP_HOME环境变量并设Hadoop conf目录参数。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="参数转为string列表"></a>参数转为String列表<a class="hash-link" href="#参数转为string列表" title="Direct link to heading">#</a></h3><p>这一部分的代码有点迷，首先调用getProgramExeArgList()方法把解析好的Options参数对象转为String列表，具体操作：</p><ol><li>查看<code>-job</code>选项配置，<strong>把文件路径字符串替换为文件内容字符串</strong>，这个逻辑藏得有点深；</li><li>查看每个选项名，加上&quot;-&quot;前缀加入String列表，再加入选项值，形成两两一对的列表。</li></ol><p>接下来把这个String列表放到HashMap中便于按键获取，然后取出<code>-p</code>选项值s，这是FlinkX提供的特性，s是<code>&quot;参数名1=参数值1,参数名2=参数值2...&quot;</code>格式的字符串，拆解成键值对，用于替换<code>-job</code>参数值json字符串中类似<code>${name}</code>的占位符。比如s=&quot;name=kay&quot;，json字符串为<code>{&quot;name&quot;: &quot;${name}&quot;}</code>，结果替换后json为<code>{&quot;name&quot;: &quot;kayhaw&quot;}</code>。</p><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>真的好吗？</h5></div><div class="admonition-content"><p>这里为了实现<code>-p</code>参数提供的特性，把Options转为String列表，又转为HashMap，这样来回倒腾，不如一开始从Options里取出job文件名和s，然后读取json文件内容为String，然后再替换变量，可以省略没有意义的转为HashMap和String列表。</p></div></div><p>接着构造JobDeployer对象，就是Options对象和变量替换后参数列表的封装。然后根据参数<code>-mode</code>的类型构造对应的xxxClusterClientHelper对象，由于以local模式运行，对应为LocalClusterClientHelper对象。</p><p>然后添加<code>-addJar</code>参数指定的扩展包，我们没有提供，跳过。最后执行LocalClusterClientHelper的submit方法，至此Launcher类已经完成了它的使命。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="flinkx执行入口mainmain"></a>FlinkX执行入口Main.main()<a class="hash-link" href="#flinkx执行入口mainmain" title="Direct link to heading">#</a></h2><p>LocalClusterClientHelper的代码如下所示，它的逻辑很简单：把JobDeployer转为字符串列表args(卧槽，泥在赣神魔！😠，又回到字符串了)，然后执行Main.main(args)方法(flinkx-core模块下)。</p><div class="codeBlockContainer_K1bP"><div style="color:#393A34;background-color:#f6f8fa" class="codeBlockTitle_eoMF">LocalClusterClientHelper.java</div><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class LocalClusterClientHelper implements ClusterClientHelper {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ClusterClient submit(JobDeployer jobDeployer) throws Exception {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 从clients.Launcher的main方法到core包下Main类的main方法</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 又把对象转成了给main方法的args字符串数组</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String[] args = jobDeployer.getProgramArgs().toArray(new String[0]);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Main.main(args);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>Main.main()方法代码如下：首先又把传入的字符串转为Options对象，并且给job字符串按UF-8重新编码，防止后续使用gson转为json对象时出错。接着获取<code>-confProp</code>参数值，我么没有给出，跳过。接着使用EnvFactory工厂类分别创建普通的流执行环境env和表执行环境tEnv(可是使用更加灵活的SQL而不是json)，由于提供的任务类型为sync，因此进入到exeSyncJob方法。</p><div class="codeBlockContainer_K1bP"><div style="color:#393A34;background-color:#f6f8fa" class="codeBlockTitle_eoMF">flinkx-core/src/main/java/com/dtstack/flinkx/Main.java</div><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public static void main(String[] args) throws Exception {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    LOG.info(&quot;------------program params-------------------------&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Arrays.stream(args).forEach(arg -&gt; LOG.info(&quot;{}&quot;, arg));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    LOG.info(&quot;-------------------------------------------&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 又把string字符串转为Options对象</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Options options = new OptionParser(args).getOptions();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 将json字符串重新编码为UTF-8，后面gson解析需要</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    String job = URLDecoder.decode(options.getJob(), Charsets.UTF_8.name());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 环境变量，只用于table执行环境</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Properties confProperties = PropertiesUtil.parseConf(options.getConfProp());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // env用于执行普通同步任务</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    StreamExecutionEnvironment env = EnvFactory.createStreamExecutionEnvironment(options);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // tenv用于执行flink sql同步任务，依赖于env</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    StreamTableEnvironment tEnv =</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            EnvFactory.createStreamTableEnvironment(env, confProperties, options.getJobName());</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    switch (EJobType.getByName(options.getJobType())) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        case SQL:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            exeSqlJob(env, tEnv, job, options);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 其实我觉得这里可以改名叫JSON</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        case SYNC:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 开始正式执行</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            exeSyncJob(env, tEnv, job, options);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        default:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new FlinkxRuntimeException(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    &quot;unknown jobType: [&quot;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                            + options.getJobType()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                            + &quot;], jobType must in [SQL, SYNC].&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    LOG.info(&quot;program {} execution success&quot;, options.getJobName());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="创建流执行环境"></a>创建流执行环境<a class="hash-link" href="#创建流执行环境" title="Direct link to heading">#</a></h3><p>EnvFactory工厂类的createStreamExecutionEnvironment和createStreamTableEnvironment方法分别用于创建普通的流执行环境env和以表形式的执行环境tEnv。以前者为例分析，代码如下所示：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public static StreamExecutionEnvironment createStreamExecutionEnvironment(Options options) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Configuration flinkConf = new Configuration();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (StringUtils.isNotEmpty(options.getFlinkConfDir())) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 给出flink conf文件夹路径并加载，loadConfiguration重载版本还可以再加一个Configuration对象来补充配置</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        flinkConf = GlobalConfiguration.loadConfiguration(options.getFlinkConfDir());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    StreamExecutionEnvironment env;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (StringUtils.equalsIgnoreCase(ClusterMode.local.name(), options.getMode())) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // local模式下，运行参数-flinkConfDir=path_to_flink_conf给出本地flink配置目录的路径</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 进而配置flink执行环境</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        env = new MyLocalStreamEnvironment(flinkConf);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 其他运行模式下，运行参数-confProp=&lt;json字符串&gt;给出来配置flink执行环境</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Configuration cfg =</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                Configuration.fromMap(PropertiesUtil.confToMap(options.getConfProp()));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        env = StreamExecutionEnvironment.getExecutionEnvironment(cfg);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 关闭闭包清理，user code已经在每个worker节点下？</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    env.getConfig().disableClosureCleaner();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return env;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>首先调用GlobalConfiguration.loadConfiguration(String conf_dir)方法得到配置类，该方法由Flink Core包提供，用于解析某个目录下的所有配置文件为Configuration对象flinkConf。如果是local模式提交任务，使用flinkConf配置生成的MyLocalStreamEnvironment，该类是FlinkX自定义的。其他模式下，环境的配置参数由<code>-confProp</code>指定。</p><div class="admonition admonition-caution alert alert--warning"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"></path></svg></span>caution</h5></div><div class="admonition-content"><p>local模式提交任务则使用本地的FlinkX conf目录下配置文件作为流执行环境的配置，其他模式远程提交到Flink集群，此时通过<code>-confProp</code>参数提供额外的执行环境配置。</p></div></div><p>接着调用disableClosureCleaner()方法关闭闭包清理器功能(默认开启)，什么是ClosureCleaner？Flink Java API Doc给出的解释如下：</p><blockquote><p>The closure cleaner is a utility that tries to truncate the closure (enclosing instance) of non-static inner classes (created for inline transformation functions). That makes non-static inner classes in many cases serializable, where Java&#x27;s default behavior renders them non-serializable without good reason.</p></blockquote><p>在Java编程中，内部类所在的外部类称之为闭包(closure)。当开启闭包清理，Flink会分析用户自定义函数中没有用到的字段，并将其设置为null，这样使得闭包或者匿名内部类是可序列化的，而某些Java工具包不会将其序列化。而用户自定义函数需要通过序列化将其分发到Flink集群的worker节点上。这里关闭了闭包清理，是因为已经在各个节点上部署了FlinkX jar包🤔？</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="执行作业exesyncjob"></a>执行作业exeSyncJob<a class="hash-link" href="#执行作业exesyncjob" title="Direct link to heading">#</a></h3><p>Main.exeSyncJob()方法的代码逻辑可以分为如下几个步骤：</p><p><strong>第一步</strong>，解析命令行参数得到配置类对象SyncConf，通过GSON.fromJson()方法解析，<strong>顺便做了参数非空校验</strong>；</p><p><strong>第二步</strong>，由configStreamExecutionEnvironment方法配置流执行环境，其中核心代码是<code>PluginUtil.registerPluginUrlToCachedFile(config, env)</code>，展开分析一下这个方法(很重要！)</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public static void registerPluginUrlToCachedFile(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            SyncConf config, StreamExecutionEnvironment env) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Set&lt;URL&gt; urlSet = new HashSet&lt;&gt;();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 这里固定死了远程插件包路径为null，getJarFileDirPath也只会取本地插件包路径了</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Set&lt;URL&gt; coreUrlList = getJarFileDirPath(&quot;&quot;, config.getPluginRoot(), null);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Set&lt;URL&gt; formatsUrlList = getJarFileDirPath(FORMATS_SUFFIX, config.getPluginRoot(), null);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Set&lt;URL&gt; sourceUrlList =</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            getJarFileDirPath(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    config.getReader().getName(),</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 注意这里插件搜索根路径换了，在connector目录下面找，sink同理</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    config.getPluginRoot() + SP + CONNECTOR_DIR_NAME,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    null);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Set&lt;URL&gt; sinkUrlList =</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            getJarFileDirPath(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    config.getWriter().getName(),</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    config.getPluginRoot() + SP + CONNECTOR_DIR_NAME,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    null);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Set&lt;URL&gt; metricUrlList =</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            getJarFileDirPath(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    config.getMetricPluginConf().getPluginName(),</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 指标插件在metrics目录下面找</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    config.getPluginRoot() + SP + METRIC_SUFFIX,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    null);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    urlSet.addAll(coreUrlList);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    urlSet.addAll(formatsUrlList);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    urlSet.addAll(sourceUrlList);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    urlSet.addAll(sinkUrlList);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    urlSet.addAll(metricUrlList);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int i = 0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (URL url : urlSet) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String classFileName = String.format(CLASS_FILE_NAME_FMT, i);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 注册所有的jar包</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        env.registerCachedFile(url.getPath(), classFileName, true);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        i++;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果是本地执行环境则直接加载，每个线程加载自己的</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (env instanceof MyLocalStreamEnvironment) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        ((MyLocalStreamEnvironment) env).setClasspaths(new ArrayList&lt;&gt;(urlSet));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (CollectionUtils.isNotEmpty(coreUrlList)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 为什么要用反射加载jar包？？？</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                Method add = URLClassLoader.class.getDeclaredMethod(&quot;addURL&quot;, URL.class);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                add.setAccessible(true);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                add.invoke(contextClassLoader, new ArrayList&lt;&gt;(coreUrlList).get(0));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (Exception e) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                LOG.warn(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        &quot;cannot add core jar into contextClassLoader, coreUrlList = {}&quot;,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        GsonUtil.GSON.toJson(coreUrlList),</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        e);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>该方法主要功能是通过getJarFileDirPath得到不同功能插件包的URL列表，然后将所有URL列表合并，最后通过Flink提供的方法registerCachedFile(String filePath, String name, boolean executable)将jar文件注册到缓存中。getJarFileDirPath的代码逻辑如下：</p><ol><li>将读写插件名称中的<code>reader</code>、<code>source</code>、<code>writer</code>和<code>sink</code>这4中后缀去掉得到插件名；</li><li>搜索<code>&lt;FlinkX插件包目录&gt;/connector/&lt;插件名&gt;</code>下的<strong>所有以flinkx开头，以.jar结尾的文件名</strong>，即读写插件jar包；</li><li>返回文件URL。</li></ol><div class="admonition admonition-caution alert alert--warning"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"></path></svg></span>注意</h5></div><div class="admonition-content"><p>这里getJarFileDirPath的第3个参数，remotePluginPath传入为null，否则优先从该路径下搜索jar文件</p></div></div><p>当给env注册完缓存文件后，如果还是local模式，则加载flinkx core包：<strong>使用线程加载器，并以反射形式调用其addURL方法()</strong>。这里使用反射是因为addURL方法是URLClassLoader类的，ClassLoader类并没有该方法。在运行时，获得的线程加载器本质是AppClassLoader，它是URLClassLoader的子类。</p><p>回到configStreamExecutionEnvironment方法，如果解析出来的配置SyncConf为空(-job参数没有提供)，并且运行模式不是local或者插件加载模式不是shipfile(参数-shipfile为1)就抛出异常，否则构造一个FactoryHelper注册到FactoryUtil和TableFactoryService的ThreadLocal对象(由于运行模式为local，这步操作的作用先略过)。</p><p>最后一步是registerShipfileToCachedFile方法，上面registerPluginUrlToCachedFile方法不同的是，<strong>它在调用env.registerCachedFile()方法时第3个参数设置为false</strong>。</p><div class="admonition admonition-caution alert alert--warning"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"></path></svg></span>caution</h5></div><div class="admonition-content"><p>registerPluginUrlToCachedFile和registerShipfileToCachedFile的不同：</p><ol><li>注册对象不同，前者是flinx-dist下的插件jar包，后者是参数<code>-shipfile</code>值(以逗号分隔的jar包路径)提供的jar包；</li><li>注册方式不同，前者注册名为<code>class_path_&lt;序号&gt;</code>，后者以jar文件名注册因此不能重名；前者executable参数为true，后者为false。</li></ol></div></div><p><strong>第三步</strong>：调用discoverSource方法获取SourceFactory实例。首先由 PluginUtil.getPluginClassName方法确定要实例化的全路径工厂类名，其构造格式为<strong>com.dtstack.flinkx.connector.&lt;插件名&gt;.source.&lt;首字母大写插件名&gt;SourceFactory</strong>；接着通过getJarFileDirPath搜索<code>${FLINK_DIST_DIR}/connector/&lt;插件名&gt;</code>的jar文件和format目录下的jar文件，合并成urlList列表。通过Flink API配置执行环境，代码如下所示：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">ConfigUtils.encodeCollectionToConfig(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 为什么不能直接env.getConfig()而是要通过反射？</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        (Configuration)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                ReflectionUtils.getDeclaredMethod(env, &quot;getConfiguration&quot;).invoke(env),</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 这是用于pipeline的jar包</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        PipelineOptions.JARS,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        urlList,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        URL::toString);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">ConfigUtils.encodeCollectionToConfig(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        (Configuration)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                ReflectionUtils.getDeclaredMethod(env, &quot;getConfiguration&quot;).invoke(env),</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        PipelineOptions.CLASSPATHS,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        urlList,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        URL::toString);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="admonition admonition-tip alert alert--success"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="16" viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>为什么用反射调用getConfiguration方法？</h5></div><div class="admonition-content"><p>getConfiguration方法是StreamExecutionEnvironment的protected方法，不能直接调用。</p></div></div><p>最后调用类加载器加载工厂类并调用其特定的构造方法返回实例，代码如下所示：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">return ClassLoaderManager.newInstance(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 为什么传入urlList？它作为key来标识之前使用的classloader</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    urlList,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // cl是classload缩写</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    cl -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Class&lt;?&gt; clazz = cl.loadClass(pluginClassName);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Constructor&lt;?&gt; constructor =</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                clazz.getConstructor(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        SyncConf.class, StreamExecutionEnvironment.class);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 调用特定的构造方法返回SourceFactory对象</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return (SourceFactory) constructor.newInstance(config, env);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    });</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>这里之所以会传入urlList列表，是因为ClassLoaderManager以url为key维护了一个ClassLoader对象缓存HashMap，通过lambda表达式执行类加载和实例化，注意使用cl时需要切换当前类加载器，代码如下所示：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public static &lt;R&gt; R callbackAndReset(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        ClassLoaderSupplier&lt;R&gt; supplier, ClassLoader toSetClassLoader) throws Exception {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 暂时地将线程类加载器替换为toSetClassLoader，然后调用supplier.get方法</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ClassLoader oldClassLoader = Thread.currentThread().getContextClassLoader();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Thread.currentThread().setContextClassLoader(toSetClassLoader);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return supplier.get(toSetClassLoader);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    } finally {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 还原旧的</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread.currentThread().setContextClassLoader(oldClassLoader);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><strong>第四步</strong>：通过sourceFactory.createSource()得到DataStream&lt;RowData&gt;，然后设置source算子并行度。这部分内容涉及source算子的实现，在下一篇文章中分析。</p><p><strong>第五步</strong>：根据json配置transformer将流环境转为表环境，由syncStreamToTable实现，由于未提供transform sql，先跳过。</p><p><strong>第六步</strong>：根据配置设置从source到sink算子的分发策略为realance()。</p><p><strong>第七步</strong>：构造SinkFactory对象并调用createSink方法创建sink算子，然后根据配置设置其并行度，逻辑同source算子，跳过。</p><p><strong>第八步</strong>：执行作业，作业名称由参数<code>-jobName</code>给出。如果是local模式运行还会打统计指标结果。</p><p>至此，FlinkX同步任务提交的主干流程分析完毕。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="总结"></a>总结<a class="hash-link" href="#总结" title="Direct link to heading">#</a></h2><p>主干流程可以归纳为3个方面的功能：</p><ol><li>运行参数的默认设置、解析和任务json变量替换等操作</li><li>流执行环境的配置，用到的Flink API有：</li></ol><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">// 1. 指定配置目录解析得到Configuration</span></span><span class="token-line" style="color:#393A34"><span class="token plain">GlobalConfiguration.loadConfiguration(String configDir)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 2. 注册缓存jar文件</span></span><span class="token-line" style="color:#393A34"><span class="token plain">StreamExecutionEnvironment.registerCachedFile(String filePath, </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    String name, boolean executable)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 3. 用于配置pipeline.jars和pipeline.classpaths参数的工具方法</span></span><span class="token-line" style="color:#393A34"><span class="token plain">ConfigUtils.encodeCollectionToConfig(WritableConfig configuration， ConfigOption&lt;List&lt;OUT&gt;&gt; key, </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Nullable Collection&lt;IN&gt; values, Function&lt;IN, OUT&gt; mapper)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ol start="3"><li>创建source和sink算子，先用反射机制构造工厂类，然后通过工厂类示例创建算子实例。</li></ol><p>执行环境配置和算子都已准备好，调用StreamExecutionEnvironment.execute()即可执行任务。总体下来参数配置的准备工作居多，最核心部分就是配置运行环境、加载算子工厂类然后创建算子。</p></div><footer class="row docusaurus-mt-lg blogPostDetailsFull_3kfx"><div class="col"><b>Tags:</b><ul class="tags_2ga9 padding--none margin-left--sm"><li class="tag_11ep"><a class="tag_1Okp tagRegular_3MiF" href="/blog/tags/flink-x">FlinkX</a></li><li class="tag_11ep"><a class="tag_1Okp tagRegular_3MiF" href="/blog/tags/source-code-dissection">Source code dissection</a></li></ul></div><div class="col margin-top--sm"><a href="https://github.com/kayhaw/kayhaw.github.io/edit/master/website/blog/blog/2022-01-09-FlinkX-Source-Code-Dissection-01.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/blog/drift"><div class="pagination-nav__sublabel">Newer Post</div><div class="pagination-nav__label">« drift</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/blog/2021/10/26/MySQLSummary"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">MySQL基础知识总结(1) »</div></a></div></nav></main><div class="col col--2"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#启动脚本" class="table-of-contents__link">启动脚本</a></li><li><a href="#命令行入口launcher" class="table-of-contents__link">命令行入口Launcher</a><ul><li><a href="#参数解析" class="table-of-contents__link">参数解析</a></li><li><a href="#默认参数配置" class="table-of-contents__link">默认参数配置</a></li><li><a href="#参数转为string列表" class="table-of-contents__link">参数转为String列表</a></li></ul></li><li><a href="#flinkx执行入口mainmain" class="table-of-contents__link">FlinkX执行入口Main.main()</a><ul><li><a href="#创建流执行环境" class="table-of-contents__link">创建流执行环境</a></li><li><a href="#执行作业exesyncjob" class="table-of-contents__link">执行作业exeSyncJob</a></li></ul></li><li><a href="#总结" class="table-of-contents__link">总结</a></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">读书笔记</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items"><li class="footer__item"><a href="https://www.zhihu.com/people/xiao-ke-dou-7" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>知乎<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/kayhaw" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://gitee.com/kayhaw" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Gitee<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 何轲(Kay Haw). Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.5c7121e2.js"></script>
<script src="/assets/js/main.eedec005.js"></script>
</body>
</html>