<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.16">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Kay Haw&#39;s Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Kay Haw&#39;s Blog Atom Feed">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" integrity="sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc" crossorigin="anonymous"><title data-rh="true">MySQL知识点总结 | Kay Haw&#x27;s Blog</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://kayhaw.github.io/blog/2022/03/02/MySQLSummary"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="MySQL知识点总结 | Kay Haw&#x27;s Blog"><meta data-rh="true" name="description" content="MySQL知识点总结"><meta data-rh="true" property="og:description" content="MySQL知识点总结"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2022-03-02T00:00:00.000Z"><meta data-rh="true" property="article:author" content="https://github.com/kayhaw"><meta data-rh="true" property="article:tag" content="MySQL,Summary"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://kayhaw.github.io/blog/2022/03/02/MySQLSummary"><link data-rh="true" rel="alternate" href="https://kayhaw.github.io/blog/2022/03/02/MySQLSummary" hreflang="en"><link data-rh="true" rel="alternate" href="https://kayhaw.github.io/blog/2022/03/02/MySQLSummary" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.4bafb564.css">
<link rel="preload" href="/assets/js/runtime~main.b8f66f99.js" as="script">
<link rel="preload" href="/assets/js/main.a8d1eeac.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="Kay Haw&#x27;s Blog" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/img/logo.svg" alt="Kay Haw&#x27;s Blog" class="themedImage_W2Cr themedImage--dark_oUvU"></div><b class="navbar__title">Kay Haw&#x27;s Blog</b></a><a class="navbar__item navbar__link" href="/docs/intro">读书笔记</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/kayhaw" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="toggle_Pssr toggle_TdHA toggleDisabled_jDku"><div class="toggleTrack_SSoT" role="button" tabindex="-1"><div class="toggleTrackCheck_XobZ"><span class="toggleIcon_eZtF">🌜</span></div><div class="toggleTrackX_YkSC"><span class="toggleIcon_eZtF">🌞</span></div><div class="toggleTrackThumb_uRm4"></div></div><input type="checkbox" class="toggleScreenReader_JnkT" aria-label="Switch between dark and light mode (currently light mode)"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper blog-wrapper blog-post-page"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_a9qW thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_uKok margin-bottom--md">Recent posts</div><ul class="sidebarItemList_Kvuv"><li class="sidebarItem_CF0Q"><a aria-current="page" class="sidebarItemLink_miNk sidebarItemLinkActive_RRTD" href="/blog/2022/03/02/MySQLSummary">MySQL知识点总结</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/03/01/RedisSummary">Redis知识点总结</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/02/27/Learning-Hive3.x-06">Hive 3.x学习笔记(6)</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/02/25/Learning-Hive3.x-05">Hive 3.x学习笔记(5)</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/02/22/Learning-Hive3.x-04">Hive 3.x学习笔记(4)</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="blogPostTitle_rzP5" itemprop="headline">MySQL知识点总结</h1><div class="blogPostData_Zg1s margin-vert--md"><time datetime="2022-03-02T00:00:00.000Z" itemprop="datePublished">March 2, 2022</time> · <!-- -->22 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_FlmR"><div class="avatar margin-bottom--sm"><a href="https://github.com/kayhaw" target="_blank" rel="noopener noreferrer" class="avatar__photo-link avatar__photo"><img class="image_o0gy" src="https://avatars.githubusercontent.com/u/16892835?v=4" alt="何轲"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/kayhaw" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">何轲</span></a></div><small class="avatar__subtitle" itemprop="description">Never settle down</small></div></div></div></div></header><div id="post-content" class="markdown" itemprop="articleBody"><p>📝MySQL知识点总结。</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="存储引擎">存储引擎<a class="hash-link" href="#存储引擎" title="Direct link to heading">​</a></h2><p>MySQL可使用的存储引擎由InnoDB和MyISAM，两者的比对如下：</p><table><thead><tr><th>对比项</th><th>MyISAM</th><th>InnoDB</th></tr></thead><tbody><tr><td>存储结构</td><td>表信息分为3个文件：frm表定义信息、MYD表数据信息和MYI索引信息</td><td>表信息为1个文件</td></tr><tr><td>文件格式</td><td>数据文件(.MYD)和索引文件(.MYI)分开</td><td>数据和索引集中存储(.ibd)</td></tr><tr><td>记录存储顺序</td><td>按记录插入顺序保存</td><td>按主键大小有序插入</td></tr><tr><td>外键</td><td>不支持</td><td>支持</td></tr><tr><td>事务</td><td>不支持</td><td>支持</td></tr><tr><td>支持锁级别</td><td>表锁</td><td>行锁、表锁</td></tr><tr><td>索引实现</td><td>B+树索引</td><td>B+数索引</td></tr><tr><td>哈希索引</td><td>支持</td><td>不支持</td></tr><tr><td>全文索引</td><td>支持</td><td>不支持</td></tr></tbody></table><p>其他区别有：</p><ol><li>InnoDB使用聚簇索引，MyISAM使用非聚簇索引；</li><li>InnoDB主键索引的叶子节点存储行数据，而MyISAM叶子节点存储行数据地址，需要再寻址一次才能得到数据；</li><li>InnDB非主键索引的叶子节点存储主键和其他索引列的数据查询时做到索引覆盖十分高效。</li></ol><h2 class="anchor anchorWithStickyNavbar_mojV" id="索引">索引<a class="hash-link" href="#索引" title="Direct link to heading">​</a></h2><p>索引时方便快速定位数据的一种数据结构，在实现上为一个文件。索引优点是可以加快数据检索速度，缺点是在增删改数据时需要维护以及占用物理空间。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="索引类型">索引类型<a class="hash-link" href="#索引类型" title="Direct link to heading">​</a></h3><ol><li>从数据结构角度：B+树索引、hash索引、全文索引；</li><li>从物理存储角度：聚簇索引、非聚簇索引(二级索引、辅助索引)；</li><li>从字段特性角度：主键索引、唯一索引、普通缩影、前缀索引；</li><li>从字段个数角度：单列索引、联合索引。</li></ol><p>其中
5. 主键索引：数据列不能重复，不能为null，一个表只能有一个主键索引；
6. 唯一索引：数据列不能重复，可以为null，一个表允许创建多个唯一索引；
7. 普通索引：数据列可以重复，可以为null，没有限制。</p><p>其他的类型还包括前缀索引：当索引字段为字符串时，为了减少索引大小，使用其前n位为作为索引；全文索引：用于文本搜索。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="索引数据结构">索引数据结构<a class="hash-link" href="#索引数据结构" title="Direct link to heading">​</a></h3><p>一般索引的数据结构有B+树和hash表两种。</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="b树和b树区别">B树和B+树区别<a class="hash-link" href="#b树和b树区别" title="Direct link to heading">​</a></h4><ol><li>B树所有节点都存放键值对，而B+树非叶子节点只存放键没有值，只有叶子节点才同时存放键和值；</li><li>B+树叶子节点之间相连形成链表，而B树叶子节点没有。</li></ol><p>由于上述两者结构的不同，把频繁访问数据放在靠近B树根节点时可以加快热点数据的查询效率，而B+数非叶子节点只存放键，相同条件下一次读取可以获取更多键，可以更快地缩小查询范围。由于叶子节点形成链表，在全局访问时可以先用O(logN)时间找到最小节点，然后用O(N)时间顺序遍历即可；但B数需要遍历每一层，需要更多的内存置换次数。总地来说：</p><ol><li>B树只适合随机检索，B+树同时支持随机检索和顺序检索；</li><li>B+树空间利用率更高，减少IO次数；</li><li>B+树随机查询效率更稳定，B树检索可能在非叶子节点结束，B+树随机检索时都需要从根节点走到叶子节点，路径长度相同，因此查询效率相当；</li><li>B+树顺序查询效率高，适合范围查询；</li><li>增删节点时B+树效率更高</li><li>B+树在满足聚簇索引和索引覆盖是不需要回表查询数据</li></ol><p>对于具有N个节点的B+树，其搜索复杂度为<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>d</mi></msub><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log_dN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="mclose">)</span></span></span></span></span>，其中d为B+树的度，实际中d值大于100，即使数据达到千万级别B+树的高度依然维持在3-4层左右，保证3-4次的磁盘IO就可以查到数据。而红黑树是二叉树，其搜索复杂度为<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>O</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(OlogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mord mathnormal" style="margin-right:0.01968em">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em">g</span><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="mclose">)</span></span></span></span></span>，树层数多导致磁盘IO也多，严重影响查询性能。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="聚簇索引与回表">聚簇索引与回表<a class="hash-link" href="#聚簇索引与回表" title="Direct link to heading">​</a></h3><p>聚簇索引：按照每张表的主键构建一个B+树，该树的叶子节点存放行数据。InnoDB通过主键建立聚簇索引，如果表没有主键，则使用非空的唯一索引，如果没有这样的索引，则隐式地生成一个主键来作为聚簇索引。聚簇索引的优点是数据访问快，对主键的排序查找和范围查找速度快，缺点是插入速度依赖于插入顺序，更新主键开销大。</p><p>非聚簇索引：又称辅助索引、二级索引，也是一个B+树，但叶子节点存放的是主键值，因此通过非聚簇索引找到主键后，再通过聚簇索引获取行数据，该过程称之为回表。回表包含2次B+树的遍历，因此效率更低。<strong>注意非聚簇索引不一定发生回表</strong>，如果查询字段就是索引字段，此时不需要回表。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="索引覆盖">索引覆盖<a class="hash-link" href="#索引覆盖" title="Direct link to heading">​</a></h3><p>当查询字段都建立索引，引擎直接返回索引表中查询结果而不会二次访问，该行为称之为索引覆盖。索引覆盖加快查询速度，因此尽可能在select字段列表中给出必要的字段。</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="事务">事务<a class="hash-link" href="#事务" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_mojV" id="事务特性acid">事务特性：ACID<a class="hash-link" href="#事务特性acid" title="Direct link to heading">​</a></h3><ul><li>原子性(<strong>A</strong>tomicity)：事务中的操作不可分割，要么全都完成，要么全都取消；</li><li>一致性(<strong>C</strong>onsistency)：事务前后的数据保持一致；</li><li>隔离性(<strong>I</strong>solation)：多个事务互不干扰；</li><li>持久性(<strong>D</strong>urability)：事务提交后产生的影响是永久的。</li></ul><p>通过<code>start</code>或<code>begin</code>命令开启事务，<code>commit</code>命令提交事务，<code>rollback</code>命令回滚事务。MySQL默认自动开启事务提交，即每执行一条语句都会提交事务。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="并发问题与隔离级别">并发问题与隔离级别<a class="hash-link" href="#并发问题与隔离级别" title="Direct link to heading">​</a></h3><p>InnoDB支持事务，但是并发事务会导致如下问题：</p><ul><li>脏读：事务B读取事务A未提交的数据；</li><li>不可重复读：事务B读取事务A已提交的<strong>修改</strong>数据；</li><li>幻读：事务B读取事务A已提交的<strong>新增</strong>数据。</li></ul><p>为了解决如上并发问题，数据库提供如下4种隔离级别：</p><ul><li>读未提交：什么问题也不能解决，相当于什么都不做；</li><li>读已提交：事务A提交后事务B才能看到其修改的数据，解决脏读问题(Oracle默认隔离级别)；</li><li>可重复读：事务A执行过程中看到的数据和该事务启动时看到的保持一致，解决脏读、不可重复读问题(MySQL默认隔离级别)；</li><li>串行化：同一行记录读加读锁、写加写锁，读写锁冲突时必须等前一个事务提交才能继续执行，解决脏读、不可重复读和幻读问题。</li></ul><p>事务隔离级别越高，解决的并发问题也越多，但是并发性能也越低。实际应用中很少用到串行化。</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="lbcc和mvcc">LBCC和MVCC<a class="hash-link" href="#lbcc和mvcc" title="Direct link to heading">​</a></h2><p>MySQL默认事务隔离级别为可重复读，为了解决该级别下出现的幻读问题，使用LBCC和MVCC两种方法。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="lbcc">LBCC<a class="hash-link" href="#lbcc" title="Direct link to heading">​</a></h3><p>LBCC是基于锁的并发控制(Lock-Based Concurrent Control)缩写。InnoDB中的锁按模式分为写锁、读锁和意向锁，按照锁粒度分为记录锁(Record Lock)、间隙锁(Gap Lock)和临键锁(Next-Key Lock)，其中临键锁可以解决可重复读下的幻读问题。</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="记录锁">记录锁<a class="hash-link" href="#记录锁" title="Direct link to heading">​</a></h4><p>记录锁对表中的一行记录加锁，也称行锁。使用<code>select .... for update</code>开启，并且对select语句有如下要求：</p><ol><li>必须使用精准匹配(如<code>=</code>或者<code>IN</code>)，而不能是范围匹配；</li><li>where过滤的列必须有唯一索引或者主键索引。</li></ol><p>也可以使用update操作开启，<strong>记录锁存在于包括主键索引在内的唯一索引中，锁定单条索引记录。</strong></p><h4 class="anchor anchorWithStickyNavbar_mojV" id="间隙锁">间隙锁<a class="hash-link" href="#间隙锁" title="Direct link to heading">​</a></h4><p>间隙锁对范围加锁，如下图所示。使用<code>select * for update</code>开启间隙锁，有如下要求：</p><ol><li>进行范围查询，匹配字段有索引，并且没有数据返回；</li><li>或者等值查询，匹配字段有唯一索引，没有数据返回。</li></ol><p>间隙锁的缺点在于锁定范围后，即使不存在的键也会被锁定，示例如下：</p><div class="codeBlockContainer_I0IT language-sql theme-code-block"><div class="codeBlockContent_wNvx sql"><pre tabindex="0" class="prism-code language-sql codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">select</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">from</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">user</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">where</span><span class="token plain"> id </span><span class="token operator" style="color:#393A34">&gt;</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">15</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">for</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">update</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">//插入失败，因为id20大于15，不难理解</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">insert</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">into</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">user</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">values</span><span class="token punctuation" style="color:#393A34">(</span><span class="token number" style="color:#36acaa">20</span><span class="token punctuation" style="color:#393A34">,</span><span class="token string" style="color:#e3116c">&#x27;20&#x27;</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">//插入失败，原因是间隙锁锁的是记录间隙，而不是sql，也就是说`select`语句的锁范围是（11，+∞），而13在这个区间中，所以也失败。</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">insert</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">into</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">user</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">values</span><span class="token punctuation" style="color:#393A34">(</span><span class="token number" style="color:#36acaa">13</span><span class="token punctuation" style="color:#393A34">,</span><span class="token string" style="color:#e3116c">&#x27;13&#x27;</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>间隙锁锁定的是记录中间的空隙，而不是sql语句中给出的空隙，间隙和锁不存在冲突关系。通过将<code>innodb_locks_unsafe_for_binlog</code>设置为OFF来开启间隙锁。</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="临键锁">临键锁<a class="hash-link" href="#临键锁" title="Direct link to heading">​</a></h4><p>临键锁同时对命中记录和间隙加锁，相当于记录锁和间隙锁的组合(左开右闭加锁)，临键锁阻止该范围内新纪录插入，即防止幻读。使用<code>select ... for update</code>下以下情况开启锁：</p><ol><li>使用范围查询有返回值，匹配列有索引；</li><li>使用等值查询不管有无返回值，匹配列有索引。</li></ol><h4 class="anchor anchorWithStickyNavbar_mojV" id="加锁总结">加锁总结<a class="hash-link" href="#加锁总结" title="Direct link to heading">​</a></h4><ol><li>如果没有查询没有命中索引，则退化为表锁；</li><li>如果等值查询唯一索引且命中，则退化为行锁；</li><li>如果等值查询唯一索引但没命中，则退化为间隙锁；</li><li>如果等值查询非唯一索引但没命中，退化为间隙锁，如果命中，则锁定所有命中行的临键锁，同时锁定最大记录行下一个区间的间隙锁；</li><li>如果范围查询命中索引，则锁定所有命中行的临键锁，同时锁定最大记录行下一个区间的间隙锁；</li><li>如果范围查询没有命中纪律，退化为临近结果的间隙锁。</li></ol><h3 class="anchor anchorWithStickyNavbar_mojV" id="mvcc">MVCC<a class="hash-link" href="#mvcc" title="Direct link to heading">​</a></h3><p>LBCC由于锁的粒度过大会导致性能下降，InnoDB使用MVCC来解决幻读问题。MVCC实现依赖于：3个隐藏字段、undo log和read view，<strong>其核心思想是只能查找事务id小于等于当前事务id的行，只能查找删除时间大于等于当前事务id的行或者未删除的行</strong>。</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="隐藏字段">隐藏字段<a class="hash-link" href="#隐藏字段" title="Direct link to heading">​</a></h4><p>MySQL为每一行记录生成如下4个隐藏字段：</p><ol><li>DB_TRX_ID：事务id，根据事务产生时间自动递增；</li><li>DB_ROLL_PTR：回滚指针，指向记录对应undo log位置，大小7字节；</li><li>DB_ROW_ID：行标识(单调自增id)，如果表没有主键，自动生成并以其产生聚簇索引，大小6字节；</li><li>flag：标识记录是否删除。</li></ol><h4 class="anchor anchorWithStickyNavbar_mojV" id="undo-log">undo log<a class="hash-link" href="#undo-log" title="Direct link to heading">​</a></h4><p>当对记录进行增删改操作时，生成如下类型的undo log：</p><ul><li>insert undo log：插入一条记录时，记下该记录主键，回滚时删除该主键对应的记录；</li><li>delete undo log：删除一条记录时，记下该记录的所有字段值，回滚时重新插入这些字段值；</li><li>update undo log：修改一条记录时，记下修改前的旧值，回滚时重新更新为旧值。</li></ul><p>每次对记录进行增删改就会形成一条undo日志，每条undo log也有一个DB_ROLL_PTR，指向上一条日志形成版本链，该链的头结点即记录的最新值。undo log并不是从物理磁盘上将数据恢复到上一个版本，它只是将数据库逻辑恢复到上一版本(逻辑日志)，因为并发情况下恢复物理页会影响其他事务。</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="read-view">read view<a class="hash-link" href="#read-view" title="Direct link to heading">​</a></h4><p>read view是使用普通select查询时产生的一致性读视图，也称快照读，它由执行查询时<strong>所有未提交事务id数组(记最小id为min_id)和已经提交事务的最大id(记为max_id)组成</strong>。执行查询时根据记录的事务id与min_id、max_id的大小关系返回结果：</p><ol><li>如果DB_TRX_ID &lt; min_id，表示该版本是已提交事务生成的，记录可以返回；</li><li>如果DB_TRX_ID &gt; max_id，表示该版本还未提交，记录不可见；</li><li>如果min_id &lt; DB_TRX_ID &lt; max_id：<ol><li>DB_TRX_ID在id数组中，表示该版本是还未提交事务生成，不可见，如果是自己的事务则可见；</li><li>DB_TRX_ID不在id数组中，表示该版本是已提交事务生成，可见。</li></ol></li></ol><p>快照读不会看到其他事务插入的数据，因此幻读只会在当前读下出现。</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="mysql日志">MySQL日志<a class="hash-link" href="#mysql日志" title="Direct link to heading">​</a></h2><p>MySQL日志包括错误日志、查询日志、慢查询日志、事务日志和二进制日志。重点介绍二进制日志binlog和事务日志redo log和undo log。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="binlog">binlog<a class="hash-link" href="#binlog" title="Direct link to heading">​</a></h3><p>binlog以二进制形式记录数据库执行的写入操作，它是逻辑日志，<strong>使用任何存储引擎的MySQL都会记录binlog日志</strong>。Bin log主要使用场景有：</p><ol><li>主从复制：在Master节点开启bin log，然后将其发送到Slave端，Slave端重放bin log实现主从一致；</li><li>数据恢复：通过mysqlbinlog工具来恢复数据。</li></ol><p>binlog通过追加方式写入日志文件，参数<code>max_binlog_size</code>控制binlog文件大小，达到该值后生成新日志文件，通过<code>sync_binlog</code>参数控制写入时机：</p><ol><li>0：由系统自行判断何时写入磁盘；</li><li>1：每次commint提交都将binlog写入磁盘；</li><li>N：每N个事务将binlog写入磁盘。</li></ol><p>MySQL 5.7.7起默认值为1，调大该值可以提升性能但会牺牲数据一致性。</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="日志格式">日志格式<a class="hash-link" href="#日志格式" title="Direct link to heading">​</a></h4><p>binlog日志格式分为如下3种，通过参数<code>binlog-format</code>指定：</p><ol><li>statement：基于SQL语句的复制(statement-based replication, SBR)，将修改数据的sql记录到binlog；<ol><li>优点：不需要记录每一行变化，减少日志量；</li><li>缺点：某些sql语句会导致主从数据不一致，如sysdate()、sleep()等。</li></ol></li><li>row：基于行的复制(row-based replication, RBR)，不记录sql语句上下文信息，仅记录哪条数据被修改<ol><li>优点：不会出现存储过程指定导致无法被正确复制的问题；</li><li>缺点：会产生大量日志，尤其alter table时。</li></ol></li><li>mixed：以上两者的融合，一般复制使用statement，处理不了的使用row模式。</li></ol><p>MySQL 5.7.7前默认为statement，之后默认为row。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="redo-log">redo log<a class="hash-link" href="#redo-log" title="Direct link to heading">​</a></h3><p>为了实现事务的持久性，最简单的方式就是在每次事务提交后将修改数据全部刷新到磁盘中，但这么做会导致两个问题：</p><ol><li>InnoDB以页为单位刷新磁盘，一个事务可能只修改了数据页中的几个字节，此时将完整页写回磁盘浪费资源；</li><li>一个事务可能修改多个数据页，而这些数据页在物理上并不连续，使用随机IO写回性能太差。</li></ol><p>因此MySQL实现redo log来记录事务对数据页进行了哪些修改，解决修改写回的性能问题。</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="写入机制">写入机制<a class="hash-link" href="#写入机制" title="Direct link to heading">​</a></h4><p>redo log包括内存中的日志缓冲redo log buffer和磁盘中的日志文件redo log file。每次执行DML语句，先将记录写入redo log buffer，然后在某个时刻一次性将多条记录写入到redo log file，这种先写内存再写磁盘的方式称为写前日志(Write Ahead Loggin，WAL)。操作系统中用户空间的缓冲区数据是无法直接写入到磁盘中，中间必须经过操作系统缓存区os buffer，因此redo buffer写入redo lof file是先写入到os buffer再通过fsync系统调用写到redo log file。redo log写入策略由参数<code>innodb_flush_log_at_trx_commit</code>控制，可选值及含义如下：</p><ul><li>0(延迟写)：事务提交不会将redo log buffer写入到os buffer，而是每秒写入os buffer然后再通过fsync写入到redo log file，即每隔1秒写回磁盘，因此故障时会丢失1秒内的数据；</li><li>1(实时写，实时刷)：每次事务提交即写入os buffer并调用fsync刷到redo log file，故障时不会丢失数据但IO性能差；</li><li>2(实时写，延迟刷)：每次事务提交写入到os buffer，然后每隔1秒调用fsync刷到redo log file。</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="日志对比">日志对比<a class="hash-link" href="#日志对比" title="Direct link to heading">​</a></h3><table><thead><tr><th>比较项</th><th>redo log</th><th>bin log</th></tr></thead><tbody><tr><td>文件大小</td><td>大小固定</td><td>大小通过参数设置</td></tr><tr><td>实现层级</td><td>InnDB引擎实现</td><td>Server层实现，所有引擎都可以使用</td></tr><tr><td>记录方式</td><td>循环写</td><td>追加写，文件大小超过设定值时记录到新文件上</td></tr><tr><td>使用场景</td><td>崩溃恢复</td><td>主从复制和数据恢复</td></tr></tbody></table><p>Redo log是物理日志，记录数据页的变化，而bin log和undo log是逻辑日志，记录执行语句。Redo log实现事务持久性，undo log实现日志原子性。在恢复数据的效率上，redo log优于bin log。</p></div><footer class="row docusaurus-mt-lg blogPostDetailsFull_h6_j"><div class="col"><b>Tags:</b><ul class="tags_XVD_ padding--none margin-left--sm"><li class="tag_JSN8"><a class="tag_hD8n tagRegular_D6E_" href="/blog/tags/my-sql">MySQL</a></li><li class="tag_JSN8"><a class="tag_hD8n tagRegular_D6E_" href="/blog/tags/summary">Summary</a></li></ul></div><div class="col margin-top--sm"><a href="https://github.com/kayhaw/kayhaw.github.io/edit/master/website/blog/blog/2022/03/02-MySQLSummary.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_dcUD" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><div class="pagination-nav__item"></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/blog/2022/03/01/RedisSummary"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">Redis知识点总结</div></a></div></nav></main><div class="col col--2"><div class="tableOfContents_cNA8 thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#存储引擎" class="table-of-contents__link toc-highlight">存储引擎</a></li><li><a href="#索引" class="table-of-contents__link toc-highlight">索引</a><ul><li><a href="#索引类型" class="table-of-contents__link toc-highlight">索引类型</a></li><li><a href="#索引数据结构" class="table-of-contents__link toc-highlight">索引数据结构</a></li><li><a href="#聚簇索引与回表" class="table-of-contents__link toc-highlight">聚簇索引与回表</a></li><li><a href="#索引覆盖" class="table-of-contents__link toc-highlight">索引覆盖</a></li></ul></li><li><a href="#事务" class="table-of-contents__link toc-highlight">事务</a><ul><li><a href="#事务特性acid" class="table-of-contents__link toc-highlight">事务特性：ACID</a></li><li><a href="#并发问题与隔离级别" class="table-of-contents__link toc-highlight">并发问题与隔离级别</a></li></ul></li><li><a href="#lbcc和mvcc" class="table-of-contents__link toc-highlight">LBCC和MVCC</a><ul><li><a href="#lbcc" class="table-of-contents__link toc-highlight">LBCC</a></li><li><a href="#mvcc" class="table-of-contents__link toc-highlight">MVCC</a></li></ul></li><li><a href="#mysql日志" class="table-of-contents__link toc-highlight">MySQL日志</a><ul><li><a href="#binlog" class="table-of-contents__link toc-highlight">binlog</a></li><li><a href="#redo-log" class="table-of-contents__link toc-highlight">redo log</a></li><li><a href="#日志对比" class="table-of-contents__link toc-highlight">日志对比</a></li></ul></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">读书笔记</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items"><li class="footer__item"><a href="https://www.zhihu.com/people/xiao-ke-dou-7" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>知乎<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/kayhaw" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://gitee.com/kayhaw" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Gitee<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 何轲(Kay Haw). Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.b8f66f99.js"></script>
<script src="/assets/js/main.a8d1eeac.js"></script>
</body>
</html>