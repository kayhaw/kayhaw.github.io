<!doctype html>
<html lang="en" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.18">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Kay Haw&#39;s Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Kay Haw&#39;s Blog Atom Feed">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" integrity="sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc" crossorigin="anonymous"><title data-rh="true">Redis知识点总结 | Kay Haw&#x27;s Blog</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://kayhaw.github.io/blog/2022/03/01/RedisSummary"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="Redis知识点总结 | Kay Haw&#x27;s Blog"><meta data-rh="true" name="description" content="Redis知识点总结"><meta data-rh="true" property="og:description" content="Redis知识点总结"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2022-03-01T00:00:00.000Z"><meta data-rh="true" property="article:author" content="https://github.com/kayhaw"><meta data-rh="true" property="article:tag" content="Redis,Summary"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://kayhaw.github.io/blog/2022/03/01/RedisSummary"><link data-rh="true" rel="alternate" href="https://kayhaw.github.io/blog/2022/03/01/RedisSummary" hreflang="en"><link data-rh="true" rel="alternate" href="https://kayhaw.github.io/blog/2022/03/01/RedisSummary" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.fe6337ec.css">
<link rel="preload" href="/assets/js/runtime~main.f054803e.js" as="script">
<link rel="preload" href="/assets/js/main.c6957282.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="Kay Haw&#x27;s Blog" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/img/logo.svg" alt="Kay Haw&#x27;s Blog" class="themedImage_W2Cr themedImage--dark_oUvU"></div><b class="navbar__title">Kay Haw&#x27;s Blog</b></a><a class="navbar__item navbar__link" href="/docs/intro">读书笔记</a><a class="navbar__item navbar__link" href="/notes">学习笔记</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/kayhaw" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_S7eR colorModeToggle_vKtC"><button class="clean-btn toggleButton_rCf9 toggleButtonDisabled_Pu9x" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_v35p"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_nQuB"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_a9qW thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_uKok margin-bottom--md">Recent posts</div><ul class="sidebarItemList_Kvuv"><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/04/06/Java_Implement_of_LRU&amp;LFU">Java实现LRU和LFU</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/03/12/HashMapSummary">HashMap知识点总结</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/03/02/MySQLSummary">MySQL知识点总结</a></li><li class="sidebarItem_CF0Q"><a aria-current="page" class="sidebarItemLink_miNk sidebarItemLinkActive_RRTD" href="/blog/2022/03/01/RedisSummary">Redis知识点总结</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/02/27/Learning-Hive3.x-06">Hive 3.x学习笔记(6)</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="blogPostTitle_rzP5" itemprop="headline">Redis知识点总结</h1><div class="blogPostData_Zg1s margin-vert--md"><time datetime="2022-03-01T00:00:00.000Z" itemprop="datePublished">March 1, 2022</time> · <!-- -->25 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_FlmR"><div class="avatar margin-bottom--sm"><span class="avatar__photo-link avatar__photo"><a href="https://github.com/kayhaw" target="_blank" rel="noopener noreferrer"><img class="image_o0gy" src="https://avatars.githubusercontent.com/u/16892835?v=4" alt="何轲"></a></span><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/kayhaw" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">何轲</span></a></div><small class="avatar__subtitle" itemprop="description">Never settle down</small></div></div></div></div></header><div id="post-content" class="markdown" itemprop="articleBody"><p>📝Redis知识点总结。</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="数据结构">数据结构<a class="hash-link" href="#数据结构" title="Direct link to heading">​</a></h2><p>Redis常用数据结构5种：String、List、Set、ZSet和Hash，这些数据结构又由如下底层数据结构支撑。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="sds">SDS<a class="hash-link" href="#sds" title="Direct link to heading">​</a></h3><p>Redis的字符串类型基于SDS(Simple Dynamic String)，相比于C语言的字符串，它具有如下优势：</p><ol><li>字段len记录字符串长度，不需要使用<code>strlen</code>方法遍历字符串计算；</li><li>空间预分配：为字符串分配空间时会申请额外的空间；</li><li>惰性空间释放：SDS缩短时不会回收多余空间，而是使用free字段记录多余空间，后续append操作直接使用减少内存申请次数。</li></ol><h3 class="anchor anchorWithStickyNavbar_mojV" id="ziplist">zipList<a class="hash-link" href="#ziplist" title="Direct link to heading">​</a></h3><p>压缩列表是list、hash和sorted set底层实现，压缩列表并不是指使用某种压缩算法来节省空间，而是使用连续内存空间来节省，ziplist又分为如下部分：</p><ul><li>zlbytes：4bytes，保存ziplist占用的内存字节数；</li><li>zltail：4bytes，保存尾节点到起始地址的偏移量，可以快速定位到尾节点；</li><li>zllen：2bytes，保存压缩列表中的节点个数；</li><li>entry：列表节点<ul><li>previous_entry_length：前一个节点的长度；</li><li>encoding：content的内容类型和长度；</li><li>content：节点内容。</li></ul></li><li>zlend：表示压缩列表结束的特殊符号<code>0xFF</code>。</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="skiplist">skipList<a class="hash-link" href="#skiplist" title="Direct link to heading">​</a></h3><p>跳表skipList是一种有序的数据结构，Redis的sorted set(zset)基于它实现。</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="redis为什么快">Redis为什么快？<a class="hash-link" href="#redis为什么快" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_mojV" id="单线程模型">单线程模型<a class="hash-link" href="#单线程模型" title="Direct link to heading">​</a></h3><p>Redis的单线程模式是指Redis网络IO(Redis 5.x之后为多线程)以及K-V读写由一个线程来执行，而Redis持久化、集群同步和异步删除是由其他线程执行，并不是说Redis程序就一个线程工作。Redis键值对的读写是单线程的，具有如下优势：</p><ol><li>避免多线程上下文切换时的开销；</li><li>避免线程创建开销；</li><li>避免多线程竞争问题；</li><li>代码清晰，逻辑简单。</li></ol><h3 class="anchor anchorWithStickyNavbar_mojV" id="io多路复用">I/O多路复用<a class="hash-link" href="#io多路复用" title="Direct link to heading">​</a></h3><p>Redis使用epoll加自行实现的事件框架来处理连接请求，不会阻塞在某个特定的客户端请求处理上，因此可以同时和多个客户端连接处理请求，提升并发性。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="全局hash表">全局Hash表<a class="hash-link" href="#全局hash表" title="Direct link to heading">​</a></h3><p>Redis使用一个全局Hash表来保存所有键值对，如下图所示。key类型为String，value类型为redisObject。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="如何处理hash冲突">如何处理Hash冲突<a class="hash-link" href="#如何处理hash冲突" title="Direct link to heading">​</a></h3><p>Redis使用链表方解决hash冲突，但是当链表长度过长时就会导致查询性能下降，此时需要增加底层hash数组的长度并rehash来进行扩容。和Java HashMap在hash数组负载达到0.75不同，Redis hash表在负载为1时进行扩容rehash，并且采用<strong>渐进式rehash</strong>。hash表有2个底层数组以及rehashidx标识，初始hash表长度为4，rehashidx为-1，当元素个数达到4时扩容为原来2倍。</p><ol><li>为ht<!-- -->[1]<!-- -->分配空间，让全局hash表同时指向ht<!-- -->[0]<!-- -->和ht<!-- -->[1]<!-- -->；</li><li>设置rehashxid为0，标识rehash开始；</li><li>每次增删改查时，将ht<!-- -->[0]<!-- -->的元素rehash到ht<!-- -->[1]<!-- -->，rehashidx加1；</li><li>随着操作执行，最终ht<!-- -->[0]<!-- -->的元素都会被rehash到ht<!-- -->[1]<!-- -->上，此时将rehashidx置为-1，标识rehash结束。</li></ol><h2 class="anchor anchorWithStickyNavbar_mojV" id="持久化">持久化<a class="hash-link" href="#持久化" title="Direct link to heading">​</a></h2><p>为了避免放在内存中的缓存数据因为故障而丢失，Redis提供RDB和AOF两种持久化机制。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="rdb">RDB<a class="hash-link" href="#rdb" title="Direct link to heading">​</a></h3><p>RDB(Redis Database)是一种快照持久化方式，它将Redis某一时刻的内存数据保存到硬盘文件中，默认文件名为dump.rdb，在Redis服务启动时会重新加载该文件到内存中以恢复数据。RDB通过如下方式开启：</p><ol><li>save命令：同步操作，Redis服务会阻塞save命令之后的所有客户端请求，当快照数据量过大时save操作执行时间较长，因此避免在生产环境中使用；</li><li>bgsave命令：异步操作，Redis服务主进程forks一个子进程将数据保存到dump.rdb文件，主进程仍可以接收其他请求但子进程是同步的；</li><li>配置文件：在redis.conf配置文件中配置，格式为<code>save N M</code>，表示在N秒内达到M条写命令则进行一次数据保存(与bgsave类似)。</li></ol><p>无论是由主进程还是子进程，生成dump.rdb文件步骤为：生成临时rdb文件并写入数据，完成数据写入用临时文件代替原rdb文件，删除原rdb文件。与rdb相关的配置有：</p><ol><li>是否开启压缩：<code>rdbcompression yes[no]</code>;</li><li>文件名称：<code>dbfilename &lt;filename&gt;</code>;</li><li>存储路径：<code>dir &lt;path&gt;</code>。</li></ol><p>😄优点：</p><ul><li>与aof相比恢复数据速度更快；</li><li>文件格式紧凑，适合数据备份；</li><li>使用子进程备份数据，有Redis主进程服务影响小</li></ul><p>😠缺点：</p><ul><li>服务器故障会丢失上一次成功备份以来的数据；</li><li>使用save命令会阻塞主进程，直到保存完成；</li><li>使用bgsave命令在数据量太大时也会发生阻塞。</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="aof">AOF<a class="hash-link" href="#aof" title="Direct link to heading">​</a></h3><p>AOF(Append-only File)记录客户端每次的写操作命令到缓冲区，然后将缓冲区数据以Redis协议<strong>追加</strong>保存到appendonly.aof文件尾部，在Redis服务启动时会加载并执行aof文件中的命令，从而恢复数据。与aof相关的配置有：</p><ol><li>是否开启aof：<code>appendonly yes[no]</code>；</li><li>文件名称：<code>appendfilename &lt;filename&gt;</code>；</li><li>写入策略：<code>appendfsync always[everysec][no]</code>；</li><li>是否重写aof文件，默认否：<code>no-appendfsync-on-rewrite no</code>；</li><li>存储路径：<code>dir &lt;path&gt;</code>。</li></ol><p>其中，写入策略可选值及其含义如下：</p><ol><li>always：每个写操作都保存到aof文件中，速度慢；</li><li>everysec：每秒写入一次aof文件，最多会丢失1s的数据；</li><li>no：由操作系统决定什么时候写入aof文件，不推荐。</li></ol><p>aof重写值将多个写操作合并生成为等价的最小命令集，比如<code>incr num 1</code>...<code>incr num 10000</code>可以重写为<code>set num 10000</code>(aof是二进制文件，并不是直接存储命令，仅是示例说明)。由于重写在每次fsync操作时进行，会影响服务性能，因此默认关闭。客户端可以通过<code>bgrewriteaof</code>命令让服务端进行aof重写。重写aof可以压缩aof文件大小，并且加快数据恢复速度。</p><div class="admonition admonition-tip alert alert--success"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="16" viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>AOF文件损坏怎么办？</h5></div><div class="admonition-content"><p>在写入aof文件时Redis服务发生故障，此时aof文件会出现格式错误，可以先复制aof文件，然后通过<code>redis-check-aof -fix &lt;appendonly.aof&gt;</code>修复。</p></div></div><p>😄优点：AOF只是追加文件，对服务器性能小，保存数据时比RDB快且消耗内存少;</p><p>😠缺点：生成日志文件太大(即使经过重写)，恢复速度比RDB慢。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="rdb-vs-aof">RDB vs AOF<a class="hash-link" href="#rdb-vs-aof" title="Direct link to heading">​</a></h3><table><thead><tr><th>对比项\方案</th><th>RDB</th><th>AOF</th></tr></thead><tbody><tr><td>工作负荷</td><td>重</td><td>轻</td></tr><tr><td>恢复速度</td><td>快</td><td>慢</td></tr><tr><td>文件体积</td><td>小</td><td>大</td></tr><tr><td>数据安全</td><td>会丢数据</td><td>由策略决定</td></tr></tbody></table><p><strong>当同时开启AOF和RDB时，Redis优先使用AOF来恢复数据，因为AOF保存记录比RDB更加完整</strong>。</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="数据淘汰策略">数据淘汰策略<a class="hash-link" href="#数据淘汰策略" title="Direct link to heading">​</a></h2><p>这里将Redis的数据淘汰策略分为2类：针对过期键值对的删除策略和针对所有键值对的内存淘汰策略。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="过期键删除策略">过期键删除策略<a class="hash-link" href="#过期键删除策略" title="Direct link to heading">​</a></h3><p>通过EXPIRE和PERSIST命令分别设置键过期时间或者永久有效，Redis通过如下3种策略删除过期键值对：</p><table><thead><tr><th>删除策略</th><th>工作机制</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>定时删除</td><td>每个有过期时间的key创建对应的定时器，到点立即删除</td><td>减少内存占用</td><td>占用大量CPU资源，影响缓存响应时间和吞吐量</td></tr><tr><td>惰性删除</td><td>当访问key时判断其是否过期再删除</td><td>最大化地节省CPU资源</td><td>大量过期key没被访问会占用大量内存</td></tr><tr><td>定期删除</td><td>每隔一段时间扫描过期key并清除</td><td>定时、惰性删除的折中方案</td><td>难以确定间隔时长</td></tr></tbody></table><p>Redis实际使用惰性删除和定期删除的组合在CPU资源和内存资源之间平衡。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="内存淘汰策略">内存淘汰策略<a class="hash-link" href="#内存淘汰策略" title="Direct link to heading">​</a></h3><p>当Redis用于缓存的内存不足时，通过如下淘汰策略处理数据：</p><table><thead><tr><th>淘汰策略</th><th>作用范围</th><th>工作机制</th></tr></thead><tbody><tr><td>noeviction(默认)</td><td>所有key</td><td>内存不足时不淘汰数据，抛出OOM异常</td></tr><tr><td>allkeys-lru</td><td>所有key</td><td>移除最近最少被使用key</td></tr><tr><td>allkeys-random</td><td>所有key</td><td>随机删除key</td></tr><tr><td>volatile-lru</td><td>过期key</td><td>移除最近最少被使用key</td></tr><tr><td>volatile-random</td><td>过期key</td><td>随机删除key</td></tr><tr><td>volatile-ttl</td><td>过期key</td><td>删除过期时间更早key</td></tr></tbody></table><p>Redis内存淘汰策略不会影响过期key删除的处理，前者用于内存不足时，后者用于处理过期的缓存数据。</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="缓存失效情况">缓存失效情况<a class="hash-link" href="#缓存失效情况" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_mojV" id="缓存雪崩">缓存雪崩<a class="hash-link" href="#缓存雪崩" title="Direct link to heading">​</a></h3><p>出现原因：极短时间内，查询大量key集中失效或者缓存服务失效，导致所有请求转到数据库，对数据库造成压力。</p><p>解决方案：</p><ol><li>加锁排队，控制请求；</li><li>设置过期标记更新缓存；</li><li>构建多级缓存架构；</li><li>不同key过期时间分散开，避免集中失效。</li></ol><h3 class="anchor anchorWithStickyNavbar_mojV" id="缓存穿透">缓存穿透<a class="hash-link" href="#缓存穿透" title="Direct link to heading">​</a></h3><p>出现原因：redis查不到数据，再深一点的就是这个key没有值，或者恶意请求不存在的key，redis没有并且数据库也没有，进行了2次无用的查询。</p><p>解决方案：</p><ol><li>设置null缓存，设置较短的过期时间</li><li>设置白名单，排除恶意请求ip</li><li>使用布隆过滤器</li></ol><h3 class="anchor anchorWithStickyNavbar_mojV" id="缓存击穿">缓存击穿<a class="hash-link" href="#缓存击穿" title="Direct link to heading">​</a></h3><p>出现原因：<strong>某个</strong>key过期，大量访问请求该key，导致数据库压力增大。</p><p>解决方案：</p><ol><li>预先设置热门数据；</li><li>实时调整过期时间；</li><li>使用锁。</li></ol><div class="admonition admonition-tip alert alert--success"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="16" viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>总结</h5></div><div class="admonition-content"><p>缓存雪崩是大量记录过期失效导致大量请求查询不到，缓存击穿是某条记录失效又有大量请求查询它导致查询不到，结果都是请求压力转到了数据库。而缓存穿透是指查询根本不存在的缓存导致请求都转到数据库。</p></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="缓存预热">缓存预热<a class="hash-link" href="#缓存预热" title="Direct link to heading">​</a></h3><p>系统上线后先直接把缓存数据加载到redis，不是等到第一次用户请求时先查询数据库再加载到redis。</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="缓存一致性">缓存一致性<a class="hash-link" href="#缓存一致性" title="Direct link to heading">​</a></h2><p>更新缓存的策略有如下4种方案：</p><ol><li>先更新缓存，再更新数据库；</li><li>先更新数据库，再更新缓存；</li><li>先删除缓存，再更新数据库；</li><li>先更新数据库，再删除缓存；</li></ol><p>制定正确的缓存更新策略第一点需要考虑更新操作失败的情况：对于方案1，如果缓存更新成功但数据库更新失败，出现缓存不一致。读操作先拿到缓存的最新值，但缓存失效后就会从数据库取到“旧值”，因此排除这种方案。对于方案2，如果数据库更新成功但是缓存更新失败，此后读缓存是“旧值”，当缓存失效后又得到正确值。</p><p>第二需要考虑的是操作并发性：对于方案3，如果更新数据库之前有查询请求，则将会脏数据刷新到缓存。对于方案4，如果更新数据库之前有查询请求，并且缓存失效，则会查询数据库“旧值”并更新缓存。</p><p>那到底是选择删除缓存还是更新缓存？一般选择删除缓存，理由如下：</p><ol><li>更新缓存有维护成本，存在并发更新问题；</li><li>写多读少场景下，读请求还没来，缓存就被频繁更新，没有起到缓存作用；</li><li>更新缓存值可能经过复杂计算，每次更新缓存值浪费性能；</li><li>删除缓存操作简单，缺点仅是造成一次cache miss。</li></ol><p>如果更新缓存开销小并且读多写少，基本没有并发写时才更新缓存，否则一般使用删除缓存。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="延迟双删">延迟双删<a class="hash-link" href="#延迟双删" title="Direct link to heading">​</a></h3><p>当选择先删除缓存再更新数据库时，可能会出现如下并发操作：</p><ol><li>线程A更新X为2，旧值为1；</li><li>线程A先删除缓存；</li><li>线程B读缓存未命中，于是从数据库读到旧值1并设置缓存；</li><li>线程A将新值2写入数据库；</li><li>线程B将旧值1写入缓存。</li></ol><p>如此形成了缓存为旧值，数据库为新值的不一致情况，为此延迟双删被提出以解决该问题，其流程如下：</p><ol><li>线程A更新X为2，旧值为1；</li><li>线程A删除缓存；</li><li>线程B读缓存未命中，从数据库读到旧值1并设置缓存；</li><li>线程A根据估算休眠一段时间，该时间大于线程B读数据加设置缓存的耗时，结束后再次删除缓存；</li><li>其他线程读缓存未命中，从数据库获取最新值并设置缓存。</li></ol><p>延迟双删解决了并发读写缓存导致的旧值回写问题，通过第2次的延迟删除确保其他线程写的旧值被删掉，其缺点是休眠时间难以评估。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="消息队列">消息队列<a class="hash-link" href="#消息队列" title="Direct link to heading">​</a></h3><p>无论是先操作缓存还是先操作数据库，都有可能执行失败，此时需要通过重试来确保操作成功。但是在本地的立即重试大概率还是失败，并且占用线程资源，并且程序重启会丢失该重试请求。为此，提出异步重试：将重试请求写入到消息队列中，由专门的消费者来重试直到成功，它利用消息队列保证可靠性和消息成功投递的特性。</p><p>更进一步地，为了免去应用程序与消息中间件交互，可以通过监听数据库bin log日志的中间件(如Canal)来投递删除请求。这样应用程序只需要和MySQL交互，无需考虑写消息队列失败请求，只要MySQL更新记录成功，bin log肯定产生相应日志，并由Canal自动投递删除请求到消息队列。</p><div class="admonition admonition-tip alert alert--success"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="16" viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>小结</h5></div><div class="admonition-content"><p>延迟双删解决的是并发场景下缓存写回旧值问题，消息队列解决的是删除操作失败问题，本质是异步重试。</p></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="高可用">高可用<a class="hash-link" href="#高可用" title="Direct link to heading">​</a></h2><p>Redis实现高可用有2种方案：主从复制、哨兵模式。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="主从复制">主从复制<a class="hash-link" href="#主从复制" title="Direct link to heading">​</a></h3><p>主从复制指将Redis主节点数据复制到从节点，又分为全量复制和部分复制2种。Redis的全量复制又分新旧版本，在旧版本中全量复制通过sync命令实现，其流程为：</p><ol><li>从服务器向主服务器发送sync命令(从节点拉)；</li><li>主服务器收到sync命令后，调用bgsave命令生成rdb文件，将其发送给从服务器；</li><li>主服务器将命令缓冲区中的写操作发送到从服务器，后者执行这些命令后，状态和主服务器当前状态保持一致。</li></ol><p>新版本中Redis使用psync代替sync，该命令既可以实现全量复制也可实现部分复制。相关概念：</p><ul><li><strong>复制偏移量</strong>：主、从服务器都会维护一个复制偏移量，当其同步了N字节数据后便将复制偏移量加N；</li><li><strong>复制积压缓冲区</strong>：主服务器维护的先进先出队列，默认大小1MB，主服务器发送写命令给从服务器时，也将命令写入到该缓冲区；</li><li><strong>服务器运行id</strong>：每个Redis服务器启动时生成的id，主服务器将其运行id发送给从服务器。</li></ul><p>基于如上概念，psync命令执行流程如下图所示：</p><p><img loading="lazy" alt="JMM.svg" src="/assets/images/psync-bfae7abec25e95ed35bdb7a48b750b0f.svg" width="421" height="291" class="img_E7b_"></p><p>从服务器发送psync命令后，主服务响应有如下3种情况：</p><ol><li>返回<code>+fullresync &lt;runid&gt; &lt;offset&gt;</code>，表示全量复制；</li><li>返回<code>+continue</code>，表示部分复制；</li><li>返回<code>-err</code>，表示主服务器Redis版本低于2.8，无法识别psync命令，此时从服务器发送sync命令执行全量复制。</li></ol><p>😠主从复制的缺点：</p><ol><li>主节点宕机后，从节点省升级为主节点，此时需要<strong>手动</strong>修改客户端应用的主节点地址以及执行命令让所有从节点复制数据；</li><li>主节点存储、写性能受单机限制，没有用到多机扩展性能；</li><li>全量同步会造成毫秒级卡顿。</li></ol><h3 class="anchor anchorWithStickyNavbar_mojV" id="哨兵模式">哨兵模式<a class="hash-link" href="#哨兵模式" title="Direct link to heading">​</a></h3><p>哨兵是Redis服务的一种运行模式，Redis哨兵节点的功能有：</p><ol><li>监控：持续监控master、slave节点是否处于预期工作状态；</li><li>切换主节点：当master运行故障，哨兵模式自动从slave中选择一台作为新master；</li><li>通知：让slave执行replicaof命令与新master同步，通知客户端与新master连接。</li></ol><h4 class="anchor anchorWithStickyNavbar_mojV" id="主观下线与客观下线">主观下线与客观下线<a class="hash-link" href="#主观下线与客观下线" title="Direct link to heading">​</a></h4><p>哨兵节点向其他所有节点发送PING命令，如果slave节点没有返回有效回复则任务标记该节点为<strong>主观下线</strong>(哨兵自己认为该节点异常)。PING命令回复有两种情况：</p><ol><li>有效回复：+PONG、-LOADING或-MASTERDOWN任意一种；</li><li>无效回复：有效回复外的回复，或者未在指定时间内返回任务回复。</li></ol><p>对于master节点，不能仅靠一个哨兵就判断其是否故障，只有当超过半数的哨兵判断master主观下线时，才标记其为<strong>客观下线</strong>(客观事实，真的不行了)，此后触发主从切换流程。</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="新master选举">新master选举<a class="hash-link" href="#新master选举" title="Direct link to heading">​</a></h4><p>当master被标记为客观下线后，需要从slave中选举出新master，该流程分为两步：先过滤再评比。</p><ol><li>过滤：筛选掉下线的slave节点，或者根据slave节点和master节点断开次数是否超过阈值；</li><li>评比：按照如下优先顺序依次比较选择优先slave<ol><li>slave优先级，通过<code>slave-priority</code>参数配置，优先级高选为新master；</li><li>复制进度，通过比较<code>slave_repl_offset</code>和<code>master_repl_offset</code>的差距选择新master；</li><li>slave runID，id最小的选为新master</li></ol></li></ol><h4 class="anchor anchorWithStickyNavbar_mojV" id="通知">通知<a class="hash-link" href="#通知" title="Direct link to heading">​</a></h4><p>哨兵将新master连接信息发送给其他slave节点，让其执行<code>replaceof</code>命令和新master建立连接并开始复制数据，同时要将新master连接信息发送给客户端。</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="哨兵集群">哨兵集群<a class="hash-link" href="#哨兵集群" title="Direct link to heading">​</a></h4><p>在了解完主从切换的流程后，接来下需要解答的问题有：</p><ul><li>哨兵如何发现彼此？
哨兵与master建立连接后通过master的发布/订阅机制发布自己信息，彼此之间互相发现建立连接。</li><li>哨兵如何发现并监控slave？
哨兵向master发送<code>INFO</code>命令，由master返回所有slave节点信息。</li><li>哪个哨兵来执行主从切换？
任何一个哨兵判断master主观下线后，向其他哨兵发送<code>is-master-down-by-addr</code>命令，其他哨兵响应投票，如果超过一半哨兵返回Y，则可以标记master客观下线。或者多数赞成票的哨兵可以向其他哨兵声明想执行主从切换，并让其他哨兵投票，该过程称为Leader选举。成为leader的条件是：或者过半赞成票并且赞成票数必须大于等于哨兵配置中quorum值。</li></ul><div class="admonition admonition-tip alert alert--success"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="16" viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>哨兵配置</h5></div><div class="admonition-content"><p>通过<code>sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</code>配置该哨兵节点连接的master节点信息和quorum值。</p></div></div><ul><li>如何通知客户端？
还是通过订阅发布机制。</li></ul></div><footer class="row docusaurus-mt-lg blogPostDetailsFull_h6_j"><div class="col"><b>Tags:</b><ul class="tags_XVD_ padding--none margin-left--sm"><li class="tag_JSN8"><a class="tag_hD8n tagRegular_D6E_" href="/blog/tags/redis">Redis</a></li><li class="tag_JSN8"><a class="tag_hD8n tagRegular_D6E_" href="/blog/tags/summary">Summary</a></li></ul></div><div class="col margin-top--sm"><a href="https://github.com/kayhaw/kayhaw.github.io/edit/master/website/blog/blog/2022/03/01-RedisSummary.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_dcUD" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/blog/2022/03/02/MySQLSummary"><div class="pagination-nav__sublabel">Newer Post</div><div class="pagination-nav__label">MySQL知识点总结</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/blog/2022/02/27/Learning-Hive3.x-06"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">Hive 3.x学习笔记(6)</div></a></div></nav></main><div class="col col--2"><div class="tableOfContents_cNA8 thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#数据结构" class="table-of-contents__link toc-highlight">数据结构</a><ul><li><a href="#sds" class="table-of-contents__link toc-highlight">SDS</a></li><li><a href="#ziplist" class="table-of-contents__link toc-highlight">zipList</a></li><li><a href="#skiplist" class="table-of-contents__link toc-highlight">skipList</a></li></ul></li><li><a href="#redis为什么快" class="table-of-contents__link toc-highlight">Redis为什么快？</a><ul><li><a href="#单线程模型" class="table-of-contents__link toc-highlight">单线程模型</a></li><li><a href="#io多路复用" class="table-of-contents__link toc-highlight">I/O多路复用</a></li><li><a href="#全局hash表" class="table-of-contents__link toc-highlight">全局Hash表</a></li><li><a href="#如何处理hash冲突" class="table-of-contents__link toc-highlight">如何处理Hash冲突</a></li></ul></li><li><a href="#持久化" class="table-of-contents__link toc-highlight">持久化</a><ul><li><a href="#rdb" class="table-of-contents__link toc-highlight">RDB</a></li><li><a href="#aof" class="table-of-contents__link toc-highlight">AOF</a></li><li><a href="#rdb-vs-aof" class="table-of-contents__link toc-highlight">RDB vs AOF</a></li></ul></li><li><a href="#数据淘汰策略" class="table-of-contents__link toc-highlight">数据淘汰策略</a><ul><li><a href="#过期键删除策略" class="table-of-contents__link toc-highlight">过期键删除策略</a></li><li><a href="#内存淘汰策略" class="table-of-contents__link toc-highlight">内存淘汰策略</a></li></ul></li><li><a href="#缓存失效情况" class="table-of-contents__link toc-highlight">缓存失效情况</a><ul><li><a href="#缓存雪崩" class="table-of-contents__link toc-highlight">缓存雪崩</a></li><li><a href="#缓存穿透" class="table-of-contents__link toc-highlight">缓存穿透</a></li><li><a href="#缓存击穿" class="table-of-contents__link toc-highlight">缓存击穿</a></li><li><a href="#缓存预热" class="table-of-contents__link toc-highlight">缓存预热</a></li></ul></li><li><a href="#缓存一致性" class="table-of-contents__link toc-highlight">缓存一致性</a><ul><li><a href="#延迟双删" class="table-of-contents__link toc-highlight">延迟双删</a></li><li><a href="#消息队列" class="table-of-contents__link toc-highlight">消息队列</a></li></ul></li><li><a href="#高可用" class="table-of-contents__link toc-highlight">高可用</a><ul><li><a href="#主从复制" class="table-of-contents__link toc-highlight">主从复制</a></li><li><a href="#哨兵模式" class="table-of-contents__link toc-highlight">哨兵模式</a></li></ul></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">读书笔记</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items"><li class="footer__item"><a href="https://www.zhihu.com/people/xiao-ke-dou-7" target="_blank" rel="noopener noreferrer" class="footer__link-item">知乎<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/kayhaw" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://gitee.com/kayhaw" target="_blank" rel="noopener noreferrer" class="footer__link-item">Gitee<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 何轲(Kay Haw). Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.f054803e.js"></script>
<script src="/assets/js/main.c6957282.js"></script>
</body>
</html>