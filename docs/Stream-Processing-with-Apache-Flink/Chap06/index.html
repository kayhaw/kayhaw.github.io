<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.6">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Kay Haw&#39;s Blog Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Kay Haw&#39;s Blog Blog Atom Feed">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" integrity="sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc" crossorigin="anonymous"><title data-react-helmet="true">Time-Based and Window Operators | Kay Haw&#x27;s Blog</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://kayhaw.github.io/docs/Stream-Processing-with-Apache-Flink/Chap06"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Time-Based and Window Operators | Kay Haw&#x27;s Blog"><meta data-react-helmet="true" name="description" content="Stream Processing with Apache Flink 第6章读书笔记"><meta data-react-helmet="true" property="og:description" content="Stream Processing with Apache Flink 第6章读书笔记"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://kayhaw.github.io/docs/Stream-Processing-with-Apache-Flink/Chap06"><link data-react-helmet="true" rel="alternate" href="https://kayhaw.github.io/docs/Stream-Processing-with-Apache-Flink/Chap06" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://kayhaw.github.io/docs/Stream-Processing-with-Apache-Flink/Chap06" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.0138175c.css">
<link rel="preload" href="/assets/js/runtime~main.b58c90ef.js" as="script">
<link rel="preload" href="/assets/js/main.30078acc.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="Kay Haw&#x27;s Blog" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo.svg" alt="Kay Haw&#x27;s Blog" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">Kay Haw&#x27;s Blog</b></a><a class="navbar__item navbar__link navbar__link--active" href="/docs/intro">读书笔记</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/kayhaw" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle toggle_3Zt9 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_31aa"><button class="clean-btn backToTopButton_35hR" type="button"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" href="/docs/intro">读书笔记</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">C++PrimerPlus</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">EffectiveC++</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Learning Akka</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">Stream Processing with Apache Flink</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Stream-Processing-with-Apache-Flink/Chap01">状态流处理简介</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Stream-Processing-with-Apache-Flink/Chap02">流处理基础</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Stream-Processing-with-Apache-Flink/Chap03">Apache Flink架构</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Stream-Processing-with-Apache-Flink/Chap04">Apache Flink开发环境搭建</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Stream-Processing-with-Apache-Flink/Chap05">DataStream API(v.14.0)</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/Stream-Processing-with-Apache-Flink/Chap06">Time-Based and Window Operators</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Stream-Processing-with-Apache-Flink/Chap07">Stateful Operators and Applications</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Stream-Processing-with-Apache-Flink/Chap08">读写外部系统</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Stream-Processing-with-Apache-Flink/Chap09">部署Flink环境</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Stream-Processing-with-Apache-Flink/Chap10">运维Flink和流应用</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Stream Processing with Apache Flink/drift">drift</a></li></ul></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Java并发编程实战</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">深入理解Java虚拟机</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">高性能MySQL</a></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="tocCollapsible_1PrD theme-doc-toc-mobile tocMobile_3Hoh"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Time-Based and Window Operators</h1></header><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p><em>Stream Processing with Apache Flink</em> 第6章读书笔记
示例代码见<a href="https://github.com/kayhaw/flink-example" target="_blank" rel="noopener noreferrer">flink-example</a></p></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="设置时间语义"></a>设置时间语义<a class="hash-link" href="#设置时间语义" title="Direct link to heading">#</a></h2><p>Flink应用的时间语义由StreamExecutionEnvironment的属性timeCharacteristic确定，它可以设置如下枚举值：</p><ol><li><p><strong>TimeCharacteristic.ProcessingTime</strong>：设置时间语义为处理时间，计算结果快但是不准确，会漏掉延迟数据。</p></li><li><p><strong>TimeCharacteristic.EventTime</strong>：设置时间语义为事件时间，数据自身提供timestamp。Timestamp可以是数据本身的一个字段，也可以在source算子上赋值。计算结果准确，为了处理乱序数据会有延迟。</p></li><li><p><strong>TimeCharacteristic.IngestionTime</strong>：指定source算子的处理时间为事件时间，可以视为ProcessingTime和EventTime的结合体。</p></li></ol><p>通过<del><code>env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)</code></del>指定应用时间语义，但从Flink 1.12起应用的默认时间语义就是<strong>EventTime</strong>，因此setStreamTimeCharacteristic已经过时，不推荐使用。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="指定timestamp和生成水印"></a>指定timestamp和生成水印<a class="hash-link" href="#指定timestamp和生成水印" title="Direct link to heading">#</a></h2><p>当设置时间语义为事件时间后，需要指定timestamp和生成水印，这里有2种方式实现：</p><ol><li><p>在SourceFunction中设置</p></li><li><p>调用<del>assignTimestampsAndWatermarks(TimestampAssigner)</del>方法</p></li></ol><p>根据<strong>水印生成离数据源越近越安全</strong>的原则，调用assignTimestampsAndWatermarks应该紧跟着source方法之后，位于所有基于事件时间的function之前，最好直接在SourceFunction中生成水印。</p><p>TimestampAssigner接口还派生出AssignerWithPeriodicWatermarks和AssignerWithPunctuatedWatermarks，表示不同的生成策略。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="周期性水印"></a><del>周期性水印</del><a class="hash-link" href="#周期性水印" title="Direct link to heading">#</a></h3><p>周期性水印默认每200ms发送一次水印，通过<code>StreamExecutionEnvironment.getConfig.setAutoWatermarkInterval(int)</code>设置发送间隔，或者实现AssignerWithPeriodicWatermarks接口的getCurrentWatermark方法。DataStream API还提供如下2个快捷项：</p><ol><li><p>如果确认输入数据的时间戳单调递增，使用快捷方法assignAscendingTimeStamps设置timestamp和水印。</p></li><li><p>如果数据乱序到达，使用BoundedOutOfOrdernessTimeStampExtractor设置timestamp和水印。</p></li></ol><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="间断性水印"></a><del>间断性水印</del><a class="hash-link" href="#间断性水印" title="Direct link to heading">#</a></h3><p>间断性水印的生成由输入数据的某些属性确定，AssignerWithPunctuatedWatermarks接口定义了checkAndGetNextWatermark()方法，该方法在每次的extractTimestamp()调用后执行，如下所示代码在id包含&quot;sensor_1&quot;时产生水印：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class SensorTimeAssigner implements AssignerWithPunctuatedWatermarks&lt;SensorReading&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Nullable</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Watermark checkAndGetNextWatermark(SensorReading lastElement, long extractedTimestamp) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(&quot;sensor_1&quot;.equals(lastElement.id)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return new Watermark(extractedTimestamp - 60*1000);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return null</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public long extractTimestamp(SensorReading element, long recordTimestamp) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return element.timestamp;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="admonition admonition-caution alert alert--warning"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"></path></svg></span>注意</h5></div><div class="admonition-content"><p>AssignerWithPeriodicWatermarks和AssignerWithPunctuatedWatermarks接口已经过时，使用WatermarkStrategy代替。</p></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="水印延迟和完整度"></a>水印，延迟和完整度<a class="hash-link" href="#水印延迟和完整度" title="Direct link to heading">#</a></h3><p>水印用于调整延迟和结果完整度的平衡，即算子在等待多久后触发计算。现实中无法设置完美的水印，因为网络等各种因素影响着结果。水印设置过大，等待时间增加，状态变量增大，但结果更准确。水印设置过小，等待时间缩减但结果不准确。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="处理函数"></a>处理函数<a class="hash-link" href="#处理函数" title="Direct link to heading">#</a></h2><p>DataStream API提供了比转换函数更底层的处理函数(Process Function)，其功能更加丰富，比如可以访问timestamp和水印。Flink提供的处理函数有：</p><ul><li>ProcessFunction</li><li>KeyedProcessFunction</li><li>CoProcessFunction</li><li>ProcessJoinFunction</li><li>BroadcastProcessFunction</li><li>KeyedBroadcastProcessFunction</li><li>ProcessWindowFunction</li></ul><p>由于这些接口类似，以KeyedProcessFunction为例介绍，该接口提供如下方法：</p><ol><li><code>processElement(I value, Context ctx, Collector&lt;O&gt; out)</code>：处理流上的每个记录value，将结果输出到out。Context对象提供timestamp和TimerService。</li><li><code>onTimer(long timestamp, OnTimerContext ctx, Collector&lt;O&gt; out)</code>：设置定时器的回调方法。</li></ol><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="timerservice和timer"></a>TimerService和Timer<a class="hash-link" href="#timerservice和timer" title="Direct link to heading">#</a></h3><p>Context和OnTimerContext都包含TimerService对象，它提供如下方法：</p><ul><li><code>long currentProcessingTime()</code>：返回当前处理时间</li><li><code>long currentWatermark()</code>：返回当前水印</li><li><code>void registerProcessingTimeTimer(long time)</code>：注册一个处理时间定时器</li><li><code>void registerEventTimeTimer(long time)</code>：注册一个事件时间定时器</li><li><code>void deleteProcessingTimeTimer(long timestamp)</code>：删除一个处理时间定时器，如果不存在则什么也不做</li><li><code>void deleteEventTimeTimer(long timestamp)</code>：删除一个事件时间定时器，如果不存在则什么也不做</li></ul><p>定时器触发后执行<code>onTimer()</code>回调，它和<code>processElement()</code>是同步的，避免并发访问状态。定时器会和其他状态一起被检查点保存。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="发送到side-outputs"></a>发送到Side Outputs<a class="hash-link" href="#发送到side-outputs" title="Direct link to heading">#</a></h3><p>通常情况下DataStream API中算子只输出单个流，只有split算子输出多个流(且基本类型不变)。但处理函数特殊之处在于它们有侧输出(Side Output)，并且基本类型可变，如下所示：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">DataStream&lt;SensorReading&gt; monitoredReadings = readings.process(new FreezingMonitor());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 获取侧输出流并打印</span></span><span class="token-line" style="color:#393A34"><span class="token plain">monitorReadings.getSideOutput(new OutputTag&lt;String&gt;(&quot;freezing-alarms&quot;)).print();</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public static class FreezingMonitor extends ProcessFunction&lt;SensorReading, SensorReading&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    OutputTag&lt;String&gt; freezingAlarmOutput = new OutputTag&lt;&gt;(&quot;freezing-alarms&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void processElement(SensorReading value, Context ctx, Collector&lt;SensorReading&gt; out) throws Exception {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(value.temperature &lt; 32.0) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            ctx.output(freezingAlarmOutput, &quot;Freezing Alarm for &quot; + value.id);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        out.collect(value);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>在processElement方法中通过Context.output()发送侧输出数据，侧输出由OutputTag对象标记识别。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="coprocessfunction"></a>CoProcessFunction<a class="hash-link" href="#coprocessfunction" title="Direct link to heading">#</a></h3><p>对于处理2个流的底层操作，DataStream API提供CoProcessFunction。和CoMapFunction类似，它提供processElement1()和processElement2()两个方法分别处理每个流的输入。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="窗口操作"></a>窗口操作<a class="hash-link" href="#窗口操作" title="Direct link to heading">#</a></h2><p>窗口操作使得在无界的流上进行聚合函数计算称为可能，本节介绍如何定义窗口算子、内置窗口类型、窗口可用函数和如何自定义窗口逻辑。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="使用窗口算子"></a>使用窗口算子<a class="hash-link" href="#使用窗口算子" title="Direct link to heading">#</a></h3><p>KeyedStream或者非KeyedStream都可以使用窗口算子，创建窗口算子需要指定如下两个组件：</p><ol><li><p>Window Assigner：决定元素如何组成窗口，即生成WindowedStream或者AllWindowedStream(在非KeyedStream上)。</p></li><li><p>Window Function：处理WindowedStream或者AllWindowedStream的元素</p></li></ol><p>如下所示为窗口操作和窗口函数使用的伪代码：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">// define a keyed window operator</span></span><span class="token-line" style="color:#393A34"><span class="token plain">stream</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  .keyBy(...)                 </span></span><span class="token-line" style="color:#393A34"><span class="token plain">  .window(...)                   // specify the window assigner</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  .reduce/aggregate/process(...) // specify the window function</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// define a nonkeyed window-all operator</span></span><span class="token-line" style="color:#393A34"><span class="token plain">stream</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  .windowAll(...)                // specify the window assigner</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  .reduce/aggregate/process(...) // specify the window function</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="内置window-assigner"></a>内置Window Assigner<a class="hash-link" href="#内置window-assigner" title="Direct link to heading">#</a></h3><p>Flink内置了许多Window Assigner满足不同使用场景，本节讨论基于时间的窗口操作(基于计数的窗口操作结果不准确)。每个窗口都有一个开始时间和一个结束时间，窗口的范围是<strong>左闭右开</strong>。以下介绍内置的开窗算子：</p><ul><li>滚动窗口</li></ul><p>滚动窗口分配器将元素分为固定大小，互不重叠的窗口，如下图所示：</p><img style="width:80%;height:80%" src="/img/doc/Stream-Processing-with-Apache-Flink/chap06/A-Tumbling-Window-Assigner-Example.png" title="A Tumbling Window Assigner Example"><p>对于事件时间语义和处理时间语义，DataStream API分别提供TumblingEventTimeWindows和TumblingProcessingTimeWindows。使用其静态方法<code>of(Time size, Time offset)</code>指定窗口大小和偏移量，代码如下所示：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">sensorData.keyBy(r -&gt; r.id)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          // timeWindow(Time.hours(1))已过时，它实际上是下面代码的封装</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          .window(TumblingEventTimeWindows.of(Time.hours(1), Time.minutes(15)))</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          .process(new TemperatureAverager());</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>滚动窗口默认和1970-01-01 00:00:00对齐，以上示例代码定义了[00:15:00-01:15:00)，[00:15:00-02:15:00)...窗口。</p><ul><li>滑动窗口</li></ul><p>滑动窗口分配器将元素分为固定大小，偏移指定大小的窗口，如下图所示：</p><img style="width:80%;height:80%" src="/img/doc/Stream-Processing-with-Apache-Flink/chap06/A-Sliding-Window-Assigner-Example.png" title="A Sliding Window Assigner Example"><p>滚动窗口需要指定窗口大小size和滑动步长slide。<strong>如果slide小于size，那么会有一些元素属于两个窗口，如果slide大于size，那么会有一些元素没有包含在窗口中。</strong>如下代码演示大小为1个小时，步长为15分钟的滑动窗口操作：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">sensorData.keyBy(r -&gt; r.id)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          .window(SlidingEventTimeWindows.of(Time.hours(1), Time.minutes(15)))</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          .process(new TemperatureAverager());</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>会话窗口</li></ul><p>会话窗口分配器将元素划分为<strong>大小不同、互不重叠</strong>的窗口，如下图所示，会话窗口的边界由session gap确定：</p><img style="width:80%;height:80%" src="/img/doc/Stream-Processing-with-Apache-Flink/chap06/A-Session-Window-Assigner-Example.png" title="A Session Window Assigner Example"><p>如下所示代码按照15分钟为gap划分会话窗口。<strong>由于分配器不能立即将元素分配到对于会话窗口，它将每个元素划分到以其timestamp为起始时间、大小为gap的独立窗口，然后合并范围重叠的独立窗口。</strong></p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">sensorData.keyBy(_.id)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">           // create event-time session windows with a 15 min gap</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          .window(EventTimeSessionWindows.withGap(Time.minutes(15)))</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          .process(...)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="窗口函数"></a>窗口函数<a class="hash-link" href="#窗口函数" title="Direct link to heading">#</a></h3><p>窗口函数对窗口内的元素进行计算，可分为两类：</p><ol><li><p>增量聚合函数：每当新元素添加到窗口时触发，优点是节省空间，例如<code>ReduceFunction</code>和<code>AggregateFunction</code>。</p></li><li><p>全量窗口函数：窗口所有元素到齐后触发，占用空间多，例如<code>ProcessWindowFunction</code>。</p></li></ol><ul><li>ReduceFunction</li></ul><p>接收2个相同类型的元素并产生一个相同类型的新元素作为窗口状态，如下示例代码计算每隔15秒的最低温度：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">DataStream&lt;Tuple2&lt;String, Double&gt;&gt; minTempPerWindow = sensorData</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    .map(r -&gt; new Tuple&lt;String, Double&gt;(r.id, r.temperature))</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    .keyBy(r -&gt; r.f1)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    .window(TumblingEventTimeWindows.of(Time.seconds(15)))</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    .reduce((r1, r2) -&gt; (r1.f1, Math.min(r1.f2, r2.f2)));</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>AggregateFunction</li></ul><p>AggregateFunction功能和ReduceFunction类似，但<strong>输入、输出元素和状态元素的类型可以互不相同</strong>，接口定义如下所示：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public interface AggregateFunction&lt;IN, ACC, OUT&gt; extends Function, Serializable {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // create a new accumulator to start a new aggregate.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  ACC createAccumulator();</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // add an input element to the accumulator and return the accumulator.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  ACC add(IN value, ACC accumulator);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // compute the result from the accumulator and return it.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  OUT getResult(ACC accumulator);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // merge two accumulators and return the result.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  ACC merge(ACC a, ACC b);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>ProcessWindowFunction</li></ul><p>ReduceFunction和AggregateFunction用于增量式地处理窗口元素，而有些时候需要窗口所有元素到齐后才能处理，比如计算中位数，此时需要ProcessWindowFunction来处理。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public abstract class ProcessWindowFunction&lt;IN, OUT, KEY, W extends Window&gt;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        extends AbstractRichFunction {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /** Evaluates the window and outputs none or several elements. */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public abstract void process(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            KEY key, Context context, Iterable&lt;IN&gt; elements, Collector&lt;OUT&gt; out) throws Exception;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /** Deletes any state in the Context when the Window expires. */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void clear(Context context) throws Exception {}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /** The context holding window metadata. */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public abstract class Context implements java.io.Serializable {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        /** Returns the window that is being evaluated. */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public abstract W window();</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        /** Returns the current processing time. */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public abstract long currentProcessingTime();</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        /** Returns the current event-time watermark. */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public abstract long currentWatermark();</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        /** State accessor for per-key and per-window state. */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public abstract KeyedStateStore windowState();</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        /** State accessor for per-key global state. */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public abstract KeyedStateStore globalState();</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        /** Emits a record to the side output identified by OutputTag. */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public abstract &lt;X&gt; void output(OutputTag&lt;X&gt; outputTag, X value);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>和ProcessFunction类似，ProcessWindowFunction也提供了Context参数扩展函数功能。ProcessWindowFunction的Context对象提供窗口元信息(比如窗口的开始、结束时间)，以及窗口状态(Per-window State)和全局状态(Global state)。</p><p>全局状态指不属于任何窗口的键控状态，窗口状态指当前窗口示例的状态。使用窗口状态时需要实现clear()方法清除之前的窗口状态，而全局状态用于状态共享。ProcessWindowFunction使用ListState存储状态，因此比ReduceFunction和AggregateFunction消耗更多的内存。</p><ul><li>增量聚合➕ProcessWindowFunction</li></ul><p>如果既想使用增量聚合又想获取窗口元信息，<strong>DataStream API提供重载的reduce()和aggregate()方法，将ProcessWindowFunction作为第二个参数传入，此时ProcessWindowFuncton的Iterable参数只有一个元素，即增量聚合后的结果</strong>，代码见<code>CalculateMinMaxTemp.java</code>。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="自定义窗口算子"></a>自定义窗口算子<a class="hash-link" href="#自定义窗口算子" title="Direct link to heading">#</a></h3><p>当内置窗口算子无法满复杂的应用逻辑时，DataStream API通过暴露接口支持自定义窗口算子。自定义窗口算子分为3个组件：</p><ul><li><p><strong>分配器(Assigner)</strong>：将新接收的元素分配到对应的窗口，如果窗口不存在则创建。</p></li><li><p><strong>触发器(Trigger)</strong>：新元素传递给窗口的同时也会给触发器，由其决定是否计算、清除窗口状态。触发器的行为取决于窗口函数。</p><ul><li>增量聚合函数立即触发并发送，如下图所示：<img style="width:80%;height:80%" src="/img/doc/Stream-Processing-with-Apache-Flink/chap06/A-Window-Operator-with-an-Incremental-Aggregation-Function.png" title="A Window Operator with an Incremental Aggregation Function"></li><li>全量窗口函数收集所有元素后处理，再发送结果，如下图所示：<img style="width:80%;height:80%" src="/img/doc/Stream-Processing-with-Apache-Flink/chap06/A-Window-Operator-with-a-Full-Window-Function.png" title="A Window Operator with a Full Window Function"></li><li>增量函数➕聚合函数，等于以上两者的结合体，如下图所示：<img style="width:80%;height:80%" src="/img/doc/Stream-Processing-with-Apache-Flink/chap06/A-Window-Operator-with-an-Incremental-Aggregation-and-Full-WIndow-Function.png" title="A Window Operator with an Incremental Aggregation and Full WIndow Function"></li></ul></li><li><p><strong>回收器(Evictor)</strong>：可选组件，可在窗口函数执行前后注入，负责将窗口元素清空，只适用于全量窗口函数。</p></li></ul><p>尽管回收器是可选的，但是每个窗口算子都需要一个触发器，每个WindowAssigner都提供一个默认触发器。<strong>注意自定义触发器并不是对默认触发器的功能补充，只有最后自定义的触发器才会生效</strong>。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="窗口生命周期"></a>窗口生命周期<a class="hash-link" href="#窗口生命周期" title="Direct link to heading">#</a></h3><p>一个窗口由WindowAssigner创建，包含如下内容：</p><ul><li>窗口内容：所有属于窗口的元素或者增量聚合函数的结果</li><li>窗口对象：WindowAssigner返回0，1或多个窗口对象，每个窗口对象包含各自区分的信息，比如窗口结束时间戳</li><li>定时器：由触发器注册，用于执行回调，比如清空窗口内容</li><li>自定义状态：触发器可以定义使用窗口状态，<strong>由触发器控制状态而不是窗口算子</strong></li></ul><p>当到达结束时间，窗口算子删除窗口内容和窗口对象，但是不会清除自定义状态，需要在Trigger.clear()方法中实现以防止内存泄漏。</p><ul><li>Window Assigner</li></ul><p>窗口分配器决定元素属于哪个窗口，WindowAssigner接口定义如下，代码<code>WindowLiftcycle.java#ThirtySecondsWindows</code>演示如何创建大小为30s的滚动窗口。：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public abstract class WindowAssigner&lt;T, W extends Window&gt; implements Serializable {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Returns a {@code Collection} of windows that should be assigned to the element.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public abstract Collection&lt;W&gt; assignWindows(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            T element, long timestamp, WindowAssignerContext context);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /** Returns the default trigger associated with this {@code WindowAssigner}. */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public abstract Trigger&lt;T, W&gt; getDefaultTrigger(StreamExecutionEnvironment env);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Returns a {@link TypeSerializer} for serializing windows that are assigned by this {@code</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * WindowAssigner}.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public abstract TypeSerializer&lt;W&gt; getWindowSerializer(ExecutionConfig executionConfig);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Returns {@code true} if elements are assigned to windows based on event time, {@code false}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * otherwise.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public abstract boolean isEventTime();</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * A context provided to the {@link WindowAssigner} that allows it to query the current</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * processing time.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * &lt;p&gt;This is provided to the assigner by its containing {@link</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * org.apache.flink.streaming.runtime.operators.windowing.WindowOperator}, which, in turn, gets</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * it from the containing {@link org.apache.flink.streaming.runtime.tasks.StreamTask}.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public abstract static class WindowAssignerContext {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        /** Returns the current processing time. */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public abstract long getCurrentProcessingTime();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="admonition admonition-note alert alert--secondary"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>GlobalWindows</h5></div><div class="admonition-content"><p>GlobalWindows将所有元素分配到一个全局窗口，其默认触发器(NeverTrigger)策略为永不触发，因此需要自定义触发器和回收器。</p></div></div><p>MergingWindowAssigner继承WindowAssigner，用于合并多个窗口，比如之前提到的会话窗口EventTimeSessionWindows。当合并窗口时，要确保窗口状态和触发器也能恰当地合并。</p><ul><li>触发器</li></ul><p>触发器定义什么时候窗口处理和发送结果，可以由时间或者特定条件(元素个数，包含某个特定元素等)确定。默认情况下，当处理时间或者水印大于窗口的终止时间时，触发器被调用并返回TirggerResult决定窗口的下一步动作，有以下枚举值：</p><ol><li><strong>CONTINUE</strong>：不触发处理，跳过。</li><li><strong>FIRE</strong>：调用ProcessWindowFunction并发送结果，如果只有增量聚合函数，发送<strong>当前聚合结果</strong>。<strong>不会改变窗口状态</strong>。</li><li><strong>PURGE</strong>：清空当前窗口所有内容，调用ProcessWindowFunction.clear()方法来清空自定义窗口状态。</li><li><strong>FIRE_AND_PURGE</strong>：先执行FIRE操作然后执行PURGE操作。</li></ol><p>Trigger提供的API能实现各种复杂的逻辑，比如说可以自定义触发几次计算更新但是不发送结果。在自定义Trigger时需要注意两方面：</p><ol><li>清空状态：<strong>实现clear()方法清除自定义窗口状态，通过TriggerContext删除所有定时器。</strong></li><li>合并Trigger：canMerge()方法返回触发器是否支持合并，onMerge()方法实现合并逻辑。</li></ol><p>代码<code>WindowLiftcycle.java#OneSecondIntervalTrigger</code>创建了一个每隔1s触发一次的Trigger。注意使用了自定义状态firstSeen，需要在clear()方法中删除，同时状态类型为ValueState不可合并，因此该Trigger也不能合并(canMerge方法默认返回false)。</p><ul><li>回收器</li></ul><p>回收器是窗口的可选组件，它在窗口函数执行之前或之后负责清除所有元素，接口定义如下：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public interface Evictor&lt;T, W extends Window&gt; extends Serializable {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /** Optionally evicts elements. Called before windowing function. */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    void evictBefore(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            Iterable&lt;TimestampedValue&lt;T&gt;&gt; elements,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            int size,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            W window,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            EvictorContext evictorContext);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /** Optionally evicts elements. Called after windowing function. */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    void evictAfter(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            Iterable&lt;TimestampedValue&lt;T&gt;&gt; elements,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            int size,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            W window,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            EvictorContext evictorContext);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /** A context object that is given to {@link Evictor} methods. */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    interface EvictorContext {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        /** Returns the current processing time. */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        long getCurrentProcessingTime();</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * Returns the metric group for this {@link Evictor}. This is the same metric group that</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * would be returned from {@link RuntimeContext#getMetricGroup()} in a user function.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * &lt;p&gt;You must not call methods that create metric objects (such as {@link</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * MetricGroup#counter(int)} multiple times but instead call once and store the metric</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * object in a field.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        MetricGroup getMetricGroup();</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        /** Returns the current watermark time. */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        long getCurrentWatermark();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>evictBefore()和evictAfter()方法在窗口函数执行前后调用，其中参数elements表示窗口所有元素，size表示元素个数，EvictorContext提供当前处理时间和水印，元素通过Iterator的remove方法删除。回收器经常应用于GlobalWindow来部分清理窗口，而不是完全清理整个窗口。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="按时间语义连接流"></a>按时间语义连接流<a class="hash-link" href="#按时间语义连接流" title="Direct link to heading">#</a></h2><p>DataStream API提供2个内置算子：<strong>间隔连接(Interval Join)</strong>和<strong>窗口连接(Window Join)</strong>，它们根据时间条件连接流。如果这两个内置算子不能满足需求，可以通过实现CoProcessFunction，BroadcastProcessFunction或者KeyedBroadcastProcessFunction接口来自定义。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="间隔连接"></a>间隔连接<a class="hash-link" href="#间隔连接" title="Direct link to heading">#</a></h3><p>间隔连接将来自两个流中<strong>key相同且时间戳间隔不大于指定值</strong>的记录合并为一个流。如下图所示为A和B的间隔连接，当B中元素的时间戳和A中元素的时间戳相比没有早于1个小时也没有晚于15分钟时，合并两个流的元素。间隔连接的语义是对称的，即A中元素相比于B中元素没有早于15分钟也没有晚于1个小时。</p><img style="width:80%;height:80%" src="/img/doc/Stream-Processing-with-Apache-Flink/chap06/An-Interval-Join-Example.png" title="An Interval Join Example"><p>间隔连接仅支持事件时间和<strong>INNER JOIN语义(没有匹配的元素不会输出)</strong>，使用伪代码如下所示：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">input1.keyBy(...)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      .between(&lt;lower-bound&gt;, &lt;upper-bound&gt;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      .process(ProcessJoinFunction)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>lower-bound和upper-bound可以任意取值，只要lower-bound小于uppder-bound，例如between(Time.hour(-1), Time.minute(15))。间隔连接需要缓存记录：对于第1条流，所有时间戳大于当前水印(upper-bound)的记录被缓存，对于第2条流，所有时间戳大于当前水印加lower-bound的记录被缓存。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="窗口连接"></a>窗口连接<a class="hash-link" href="#窗口连接" title="Direct link to heading">#</a></h3><p>窗口连接基于窗口机制，伪代码如下所示：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">input1.join(input2)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      .where(...)       // 指定input1的key属性</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      .equalTo(...)     // 指定input2的key属性</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      .window(...)      // 指定窗口分配器</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      [.trigger(...)]</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      [.evictor(...)]</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      .apply(...)       // 指定JoinFunction</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>窗口连接机制如下图所示，2个输入流按照key分配到公共窗口(包含两个流的记录)，再由JoinFunction处理两个流的交叉积。</p><img style="width:80%;height:80%" src="/img/doc/Stream-Processing-with-Apache-Flink/chap06/Operation-of-a-Window-Join.png" title="Operation of a Window Join"><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="处理延迟数据"></a>处理延迟数据<a class="hash-link" href="#处理延迟数据" title="Direct link to heading">#</a></h2><p>DataStream API提供如下策略来处理延迟数据，示例代码见<code>HandleLateData.java</code>：</p><ul><li>丢弃不管</li><li>重定向到另一个流</li><li>用迟延数据再次更新结果并输出</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="丢弃"></a>丢弃<a class="hash-link" href="#丢弃" title="Direct link to heading">#</a></h3><p>最简单的处理策略，是基于事件时间的窗口算子的默认行为。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="重定向"></a>重定向<a class="hash-link" href="#重定向" title="Direct link to heading">#</a></h3><p>将延迟数据重定向到侧输出流，可以使用sideOutputLateData方法或者在ProcessFunction中自行重定向。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="更新结果"></a>更新结果<a class="hash-link" href="#更新结果" title="Direct link to heading">#</a></h3><p>将延迟的记录重新处理生成更新结果并发送，但需要算子满足特定要求。<strong>第一点需要算子保存所有状态，第二点需要下游算子和外部系统支持更新。</strong>窗口算子提供allowedLateness()方法设置额外的延迟时间，当水印大于窗口的终止时间后不会删除窗口，而是再等待相应的延迟事件后才删除。也可以在ProcessFunction中实现等待延迟时间的逻辑。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="总结"></a>总结<a class="hash-link" href="#总结" title="Direct link to heading">#</a></h2><ol><li>时间语义默认为事件时间可以不设置，使用WatermarkStrategy来设置水印和时间戳；</li><li>处理函数比转换函数功能更加丰富：获取水印，设置/删除定时器，侧输出等；</li><li>一般使用窗口操作只需要指定分配器和提供窗口函数：内置实现的分配器有滚动、滑动和会话，窗口函数分为增量聚合函数(ReduceFunction、AggregateFunction)和全量窗口函数(ProcessWindowFunction)两类；</li><li>自定义窗口算子分为3个组件：分配器、触发器和回收器。自定义组件即实现WindowAssigner、Trigger、Evictor这些接口/抽象类；</li><li>触发器的4种结果：CONTINUE、FIRE、PURGE和FIRE_AND_PURGE影响窗口算子下一步操作。回收器是可选组件，通常用于GlobalWindow；</li><li>按时间语义连接流的2种方式：间隔连接和窗口连接；</li><li>处理延迟数据的3种策略：丢弃、重定向和更新结果。重定义可以用sideOutputLateData()或者在ProcessFunction中实现，更新结果需要设置额外延迟事件。</li></ol></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-tags-row row margin-bottom--sm"><div class="col"><b>Tags:</b><ul class="tags_2ga9 padding--none margin-left--sm"><li class="tag_11ep"><a class="tag_1Okp tagRegular_3MiF" href="/docs/tags/stream-processing">Stream Processing</a></li><li class="tag_11ep"><a class="tag_1Okp tagRegular_3MiF" href="/docs/tags/apache-flink">Apache Flink</a></li><li class="tag_11ep"><a class="tag_1Okp tagRegular_3MiF" href="/docs/tags/reading-notes">ReadingNotes</a></li></ul></div></div><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/kayhaw/kayhaw.github.io/edit/master/website/docs/Stream Processing with Apache Flink/Stream-Processing-with-Apache-Flink-Chap06.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_13-_"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/Stream-Processing-with-Apache-Flink/Chap05"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« DataStream API(v.14.0)</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/Stream-Processing-with-Apache-Flink/Chap07"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Stateful Operators and Applications »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#设置时间语义" class="table-of-contents__link">设置时间语义</a></li><li><a href="#指定timestamp和生成水印" class="table-of-contents__link">指定timestamp和生成水印</a><ul><li><a href="#周期性水印" class="table-of-contents__link"><del>周期性水印</del></a></li><li><a href="#间断性水印" class="table-of-contents__link"><del>间断性水印</del></a></li><li><a href="#水印延迟和完整度" class="table-of-contents__link">水印，延迟和完整度</a></li></ul></li><li><a href="#处理函数" class="table-of-contents__link">处理函数</a><ul><li><a href="#timerservice和timer" class="table-of-contents__link">TimerService和Timer</a></li><li><a href="#发送到side-outputs" class="table-of-contents__link">发送到Side Outputs</a></li><li><a href="#coprocessfunction" class="table-of-contents__link">CoProcessFunction</a></li></ul></li><li><a href="#窗口操作" class="table-of-contents__link">窗口操作</a><ul><li><a href="#使用窗口算子" class="table-of-contents__link">使用窗口算子</a></li><li><a href="#内置window-assigner" class="table-of-contents__link">内置Window Assigner</a></li><li><a href="#窗口函数" class="table-of-contents__link">窗口函数</a></li><li><a href="#自定义窗口算子" class="table-of-contents__link">自定义窗口算子</a></li><li><a href="#窗口生命周期" class="table-of-contents__link">窗口生命周期</a></li></ul></li><li><a href="#按时间语义连接流" class="table-of-contents__link">按时间语义连接流</a><ul><li><a href="#间隔连接" class="table-of-contents__link">间隔连接</a></li><li><a href="#窗口连接" class="table-of-contents__link">窗口连接</a></li></ul></li><li><a href="#处理延迟数据" class="table-of-contents__link">处理延迟数据</a><ul><li><a href="#丢弃" class="table-of-contents__link">丢弃</a></li><li><a href="#重定向" class="table-of-contents__link">重定向</a></li><li><a href="#更新结果" class="table-of-contents__link">更新结果</a></li></ul></li><li><a href="#总结" class="table-of-contents__link">总结</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">读书笔记</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items"><li class="footer__item"><a href="https://www.zhihu.com/people/xiao-ke-dou-7" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>知乎<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/kayhaw" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://gitee.com/kayhaw" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Gitee<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 何轲(Kay Haw). Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.b58c90ef.js"></script>
<script src="/assets/js/main.30078acc.js"></script>
</body>
</html>