<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.6">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Kay Haw&#39;s Blog Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Kay Haw&#39;s Blog Blog Atom Feed">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" integrity="sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc" crossorigin="anonymous"><title data-react-helmet="true">基础构建模块 | Kay Haw&#x27;s Blog</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://kayhaw.github.io/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap05"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="基础构建模块 | Kay Haw&#x27;s Blog"><meta data-react-helmet="true" name="description" content="《Java并发编程》第五章读书笔记"><meta data-react-helmet="true" property="og:description" content="《Java并发编程》第五章读书笔记"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://kayhaw.github.io/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap05"><link data-react-helmet="true" rel="alternate" href="https://kayhaw.github.io/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap05" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://kayhaw.github.io/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap05" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.0138175c.css">
<link rel="preload" href="/assets/js/runtime~main.5c7121e2.js" as="script">
<link rel="preload" href="/assets/js/main.eedec005.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="Kay Haw&#x27;s Blog" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo.svg" alt="Kay Haw&#x27;s Blog" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">Kay Haw&#x27;s Blog</b></a><a class="navbar__item navbar__link navbar__link--active" href="/docs/intro">读书笔记</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/kayhaw" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle toggle_3Zt9 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_31aa"><button class="clean-btn backToTopButton_35hR" type="button"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" href="/docs/intro">读书笔记</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">C++PrimerPlus</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">EffectiveC++</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Learning Akka</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Stream Processing with Apache Flink</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">Java并发编程实战</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap02">线程安全性</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap03">对象的共享</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap04">对象的组合</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap05">基础构建模块</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap06">任务执行</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap07">取消与关闭</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap08">线程池的使用</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap10">避免活跃性危险</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap13">显式锁</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap14">构建自定义的同步工具</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap15">原子变量与非阻塞同步机制</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap16">Java内存模型</a></li></ul></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">深入理解Java虚拟机</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">高性能MySQL</a></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="tocCollapsible_1PrD theme-doc-toc-mobile tocMobile_3Hoh"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>基础构建模块</h1></header><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p>《Java并发编程》第五章读书笔记</p></div></div><p>上一章介绍构造线程安全类的一些技术，本章介绍Java类库提供的同步工具类，以及使用它们的常用模式。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="同步容器类"></a>同步容器类<a class="hash-link" href="#同步容器类" title="Direct link to heading">#</a></h2><p>早期同步容器类包括Vector和Hashtable，后续加入Collections.synchronizedXxx工厂方法提供的同步容器封装类。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="同步容器类的问题"></a>同步容器类的问题<a class="hash-link" href="#同步容器类的问题" title="Direct link to heading">#</a></h3><p>同步容器本身是线程安全的，但在它们身上进行的复合操作（迭代遍历、跳转以及条件运算）会出现问题，如下代码所示：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class UnsafeVectorHelpers {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static Object getLast(Vector list) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int lastIndex = list.size() - 1;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return list.get(lastIndex);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void deleteLast(Vector list) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int lastIndex = list.size() - 1;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        list.remove(lastIndex);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>假设线程A调用getLast获取容器最后一个元素，线程B调用deleteLast删除容器最后一个元素。在某种特定的执行顺序下，可能出现A获取B删除的元素，导致getLast抛出索引越界异常。此时可以通过客户端加锁解决这个问题，代码如下所示，客户端加锁粒度过大，牺牲了伸缩性，降低了并发度。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class SafeVectorHelpers {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static Object getLast(Vector list) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        synchronized (list) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            int lastIndex = list.size() - 1;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return list.get(lastIndex);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void deleteLast(Vector list) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        synchronized (list) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            int lastIndex = list.size() - 1;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            list.remove(lastIndex);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="admonition admonition-caution alert alert--warning"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"></path></svg></span>同步容器到底线程安全吗？</h5></div><div class="admonition-content"><p>复合操作在某些情况下导致问题，原书描述为<em>这并不意味着Vector就不是线程安全的，因为Vector状态依然有限，并且抛出的异常也与其规范保持一致</em>。</p></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="迭代器与concurrentmodificationexception"></a>迭代器与ConcurrentModificationException<a class="hash-link" href="#迭代器与concurrentmodificationexception" title="Direct link to heading">#</a></h3><p>遍历同步容器的标准方式是使用迭代器，但迭代作为复合操作也会多线程修改容器下出现问题。<strong>在设计同步容器类的迭代器时并没有考虑并发修改的问题</strong>，当这种情况出现时，会抛出ConcurrentModificationException异常（Fail-Fast机制）。具体的实现方式是维护一个容器大小的计数器，当迭代期间计数器发生变化即抛出该异常。<strong>注意这种检查是没有在同步情况下执行的</strong>，这是设计上的权衡，为了降低检测代码带来的影响。</p><div class="admonition admonition-caution alert alert--warning"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"></path></svg></span>注意</h5></div><div class="admonition-content"><p>当直接从容器删除元素而不是使用迭代器时，单线程情况下也会抛出ConcurrentModificationException异常。</p></div></div><p>要想完全消除可能抛出的ConcurrentModificationException异常，有两种解决方式：</p><ol><li>对容器加锁：当容器元素很多，访问元素执行操作时间很长时，可能会产生死锁。</li><li>克隆容器：在副本上进行迭代，但克隆过程中仍需要对容器加锁</li></ol><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="隐藏迭代器"></a>隐藏迭代器<a class="hash-link" href="#隐藏迭代器" title="Direct link to heading">#</a></h3><p>注意迭代器操作在代码中可能并没有那么明显，如下代码所示，打印日志操作包含了一个隐藏的迭代操作：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class HiddenIterator {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public synchronized void add(Integer i) { set.add(i); }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public synchronized void remove(Integer i) { set.remove(i); }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void addTenThings() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Random r = new Random();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; 10; i++)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            add(r.nextInt());</span></span><span class="token-line docusaurus-highlight-code-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;DEBUG: added ten elements to &quot; + set);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>编译器将字符串的连接操作转为StringBuilder.append调用，这个方法又会调用set的toString方法，而标准容器的toString方法又会<strong>迭代</strong>容器调用每个元素的toString方法生成最后的字符串，类似的方法还包括hashCode、equals、containsAll等，它们都有可能抛出ConcurrentModificationException异常。</p><div class="admonition admonition-danger alert alert--danger"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="16" viewBox="0 0 12 16"><path fill-rule="evenodd" d="M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"></path></svg></span>小心</h5></div><div class="admonition-content"><p>状态和保护它们的同步代码之间相隔越远，开发人员越容易忘记使用正确的同步</p></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="并发容器"></a>并发容器<a class="hash-link" href="#并发容器" title="Direct link to heading">#</a></h2><p>鉴于同步容器的性能问题（串行化状态访问），Java 5.0提供了并发容器来改进，如ConcurrentMap接口新增了Put-If-Absent、条件删除等复合操作。Java 5.0新增了Queue和BlockingQueue两种容器，阻塞队列在队列的基础上扩展了可阻塞的插入和获取操作。Java 6也引入了ConcurrentSkipListMap和ConcurrentSkipListSet分别代替TreeMap、TreeSet。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="concurrenthashmap"></a>ConcurrentHashMap<a class="hash-link" href="#concurrenthashmap" title="Direct link to heading">#</a></h3><p>同步容器粗粒度的并发策略使得每次只有一个线程访问容器，ConcurrentHashMap使用粒度更细的分段锁机制来实现最大程度的共享。作为并发容器，它不会抛出ConcurrentModificationException异常，但是返回的迭代器具有弱一致性而非Fast-Fail。ConcurrentHashMap的size、isEmpty等方法语义被削弱，并不代表容器的实际状态，只有当需要对整个Map加锁进行独占访问时才放弃使用ConcurrentHashMap，总体来说利大于弊。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="额外的原子map操作"></a>额外的原子Map操作<a class="hash-link" href="#额外的原子map操作" title="Direct link to heading">#</a></h3><p>ConcurrentHashMap不能被加锁来执行独占访问，因此无法用客户端加锁方式实现原子操作。但ConcurrentHashMap已经声明并实现了诸如Put-If-Absent、Remove-If-Equal、Replace-If-Equal等复合操作。当在现有同步Map上添加复合操作时，考虑使用ConcurrentHashMap代替。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="copyonwritearraylist"></a>CopyOnWriteArrayList<a class="hash-link" href="#copyonwritearraylist" title="Direct link to heading">#</a></h3><p>CopyOnWriteArrayList(Set)作为同步List(Set)的替代品，在迭代期间不需要对容器加锁或复制(准确地来说是读时不复制)。“写时复制”容器不会抛出ConcurrentModificationException异常，返回元素与创建迭代器时的一致。仅当读操作远多于写操作时，才应该使用写时复制容器，比例事件通知系统：分发通知时迭代已注册监听器列表并调用监听器，大多数情况下监听器的注册和注销远少于接收事件通知的操作。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="阻塞队列和生产者-消费者模式"></a>阻塞队列和生产者-消费者模式<a class="hash-link" href="#阻塞队列和生产者-消费者模式" title="Direct link to heading">#</a></h2><p>生产者-消费者模式将“找出需要完成的工作”与“执行工作”解耦，同时也将生产数据与使用数据解耦，解决两者速率相差过大的负载问题。而阻塞队列天生支持生产者-消费者模式，提供阻塞的put/take方法和定时的offer/poll方法。阻塞队列分为以下几类：</p><ol><li>LinkedBlockingQueue/ArrayBlockingQueue，基于FIFO策略的阻塞队列</li><li>PriorityBlockingQueue，基于优先级的阻塞队列</li><li>SynchronousQueue，维护一组线程</li></ol><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="示例桌面搜索"></a>示例：桌面搜索<a class="hash-link" href="#示例桌面搜索" title="Direct link to heading">#</a></h3><p>阻塞队列代码模板，生产者/消费者线程，使用阻塞队列作为成员，在主线程中创建阻塞队列并将引用作为参数传给生产者/消费者线程的构造器：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class ProducerConsumer {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    static class FileCrawler implements Runnable {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        private final BlockingQueue&lt;File&gt; fileQueue;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        private final FileFilter fileFilter;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        private final File root;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public FileCrawler(BlockingQueue&lt;File&gt; fileQueue,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                           final FileFilter fileFilter,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                           File root) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.fileQueue = fileQueue;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.root = root;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.fileFilter = new FileFilter() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                public boolean accept(File f) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return f.isDirectory() || fileFilter.accept(f);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            };</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        private boolean alreadyIndexed(File f) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return false;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void run() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                crawl(root);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (InterruptedException e) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                Thread.currentThread().interrupt();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        private void crawl(File root) throws InterruptedException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            File[] entries = root.listFiles(fileFilter);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (entries != null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                for (File entry : entries)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (entry.isDirectory())</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        crawl(entry);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    else if (!alreadyIndexed(entry))</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        fileQueue.put(entry);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    static class Indexer implements Runnable {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        private final BlockingQueue&lt;File&gt; queue;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public Indexer(BlockingQueue&lt;File&gt; queue) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.queue = queue;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void run() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                while (true)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    indexFile(queue.take());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (InterruptedException e) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                Thread.currentThread().interrupt();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void indexFile(File file) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Index the file...</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final int BOUND = 10;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final int N_CONSUMERS = Runtime.getRuntime().availableProcessors();</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void startIndexing(File[] roots) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        BlockingQueue&lt;File&gt; queue = new LinkedBlockingQueue&lt;File&gt;(BOUND);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        FileFilter filter = new FileFilter() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            public boolean accept(File file) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                return true;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (File root : roots)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            new Thread(new FileCrawler(queue, filter, root)).start();</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; N_CONSUMERS; i++)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            new Thread(new Indexer(queue)).start();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="串行线程封闭"></a>串行线程封闭<a class="hash-link" href="#串行线程封闭" title="Direct link to heading">#</a></h3><p>阻塞队列的同步机制使得队列中的对象从生产者线程<strong>发布</strong>到消费者线程是安全的。线程封闭指对象只能有单个线程所有，但是可以安全发布对象来转移对象所有权。若转移后只有一个线程拥有对象且之前所有者不会再访问它，对象仍然是线程封闭的。因此，阻塞队列也可视为一种串行线程封闭，其他类似机制还包括ConcurrentMap的原子方法remove或者AtomicReference的原子方法compareAndSet。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="双端队列与工作密取"></a>双端队列与工作密取<a class="hash-link" href="#双端队列与工作密取" title="Direct link to heading">#</a></h3><p>Java 6新增了双端队列Deque（发音同deck）和BlockingDeque分别对Queue和BlockingQueue扩展。双端队列使用于工作密取(Work Stealing)模式，每个消费者线程都有<strong>各自</strong>的双端队列，当完成自己队列中的任务后，还可以从尾端获取其他消费者的双端队列，<strong>适用于既是生产者又是消费者的场景(执行任务时出现了更多任务)</strong>。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="阻塞方法与中断方法"></a>阻塞方法与中断方法<a class="hash-link" href="#阻塞方法与中断方法" title="Direct link to heading">#</a></h2><p>阻塞队列的put\take等方法会抛出受检查异常InterruptedException，表明该方法是阻塞方法，若方法被中断，它会努力提前结束阻塞状态。每个线程都有一个boolean类型的中断状态，Thread类的interrupt方法检查该状态判断是否被中断，</p><p>当调用将抛出InterruptedException异常的方法，此时调用方也成为阻塞方法，需要处理中断，通常有以下两种方法：</p><ul><li>传递InterruptedException：不捕获异常\捕获后简单处理再次抛出</li><li>恢复中断：调用interrupt方法恢复中断状态</li></ul><p>错误的处理方式是捕获但是不做任何响应，此时线程被中断的证据已经丢失。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="同步工具类"></a>同步工具类<a class="hash-link" href="#同步工具类" title="Direct link to heading">#</a></h2><p>同步工具类可以是任何一个对象，只要它根据自身状态来协调线程的控制流。除了阻塞队列外，Java类库还提供了其他同步工具类，以下逐一介绍。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="闭锁"></a>闭锁<a class="hash-link" href="#闭锁" title="Direct link to heading">#</a></h3><p>闭锁是一种同步工具类，当闭锁到达结束状态之前，所有等待该闭锁的线程被阻塞，当到达结束状态后，所有线程开始执行并且<strong>闭锁状态不会再改变</strong>。闭锁用于确保某些活动在其他活动完成后才继续执行。</p><p>CountDownLatch是一种灵活的闭锁实现，其构造函数接收一个正整数作为，提供countDown方法将计数器减一，提供await方法阻塞线程直达计数器为0。如下示例代码使用CountDownLatch计算所有线程完成工作总时间：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class TestHarness {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public long timeTasks(int nThreads, final Runnable task)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            throws InterruptedException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        final CountDownLatch startGate = new CountDownLatch(1);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        final CountDownLatch endGate = new CountDownLatch(nThreads);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; nThreads; i++) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            Thread t = new Thread() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                public void run() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        startGate.await();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                            task.run();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        } finally {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                            endGate.countDown();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } catch (InterruptedException ignored) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            };</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            t.start();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        long start = System.nanoTime();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        startGate.countDown();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        endGate.await();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        long end = System.nanoTime();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return end - start;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>这里使用了两个闭锁，分别表示起始门和结束门。起始门初始值为1，主线程将其减1，如此确保所有工作线程准备就绪后一同开始执行任务。结束门初始值为工作线程个数，工作线程结束后将其减1，如此确保最后一个工作线程结束后主线程结束。</p><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>为什么要用起始门，一个结束门不就可以吗？</h5></div><div class="admonition-content"><p>为了确保所有工作线程“同时”开始执行，否则先start的线程先结束，可能导致最后统计时间偏大</p></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="futuretask"></a>FutureTask<a class="hash-link" href="#futuretask" title="Direct link to heading">#</a></h3><p>FutureTask也可作为一种闭锁实现，它是Callable计算结果的占位符。FutureTask有3中状态：等待执行、正在执行、运行完成，当进入完成状态后便永远停留在这个状态。</p><p>FutureTask.get()方法用于获取结果，若任务完成则立即返回，否则get将阻塞直到任务完成或者抛出异常。如下代码所示，表示一个异步异步加载产品信息的任务。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class Preloader {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ProductInfo loadProductInfo() throws DataLoadException { return null; }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final FutureTask&lt;ProductInfo&gt; future =</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        new FutureTask&lt;ProductInfo&gt;(new Callable&lt;ProductInfo&gt;() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            public ProductInfo call() throws DataLoadException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                return loadProductInfo();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Thread thread = new Thread(future);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void start() { thread.start(); }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ProductInfo get() throws DataLoadException, InterruptedException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return future.get();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (ExecutionException e) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            Throwable cause = e.getCause();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (cause instanceof DataLoadException)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                throw (DataLoadException) cause;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            else</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                throw LaunderThrowable.launderThrowable(cause);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    interface ProductInfo {}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">class DataLoadException extends Exception { }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>为了避免在构造函数中调用start()方法，包装了start方法来调用线程。注意get方法抛出的异常都会被封装到一个ExecutionException中，需要根据情况分别处理。当异常时受检查异常时，重新抛出，否则使用LaunderThrowable.launderThrowable方法处理，代码如下所示。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class LaunderThrowable {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Coerce an unchecked Throwable to a RuntimeException</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * &lt;p/&gt;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * If the Throwable is an Error, throw it; if it is a</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * RuntimeException return it, otherwise throw IllegalStateException</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static RuntimeException launderThrowable(Throwable t) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (t instanceof RuntimeException)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return (RuntimeException) t;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        else if (t instanceof Error)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw (Error) t;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        else</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new IllegalStateException(&quot;Not unchecked&quot;, t);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="信号量"></a>信号量<a class="hash-link" href="#信号量" title="Direct link to heading">#</a></h3><p>信号量(Semaphore)用于控制访问某个特定资源的操作数量或者某个指定操作的数量，还可以用于实现资源池或者将容器变成有界阻塞容器。示例代码如下所示：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class BoundedHashSet &lt;T&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Set&lt;T&gt; set;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Semaphore sem;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public BoundedHashSet(int bound) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.set = Collections.synchronizedSet(new HashSet&lt;T&gt;());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        sem = new Semaphore(bound);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean add(T o) throws InterruptedException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        sem.acquire();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        boolean wasAdded = false;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            wasAdded = set.add(o);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return wasAdded;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!wasAdded)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                sem.release();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean remove(Object o) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        boolean wasRemoved = set.remove(o);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (wasRemoved)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            sem.release();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return wasRemoved;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>Semaphore构造方法传入一个正数作为初始许可证个数，提供方法release和acquire分别新增和减少一个许可证。当许可证个数为0时，acquire方法被阻塞。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="栅栏"></a>栅栏<a class="hash-link" href="#栅栏" title="Direct link to heading">#</a></h3><p>栅栏(Barrier)类似闭锁，它能阻塞一组线程直到某个事件发生。栅栏和闭锁的区别：</p><ol><li>闭锁用于等待事件，栅栏用于等待其他线程</li><li>闭锁不可重置复用，栅栏可以使线程反复在栅栏位置汇集</li><li>CountDownLatch是减1到0后同时执行，Barrier是加1到特定值后同时执行</li></ol><p>栅栏提供await方法将阻塞到所有线程都到达栅栏位置，此时栅栏打开，所有线程被释放，同时栅栏被重置供下次使用。如果await调用超时或者await阻塞的线程被中断，那么栅栏被认为打破，所有阻塞await调用抛出BrokenBarrierException。示例代码如下所示：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class CellularAutomata {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Board mainBoard;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final CyclicBarrier barrier;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Worker[] workers;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public CellularAutomata(Board board) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.mainBoard = board;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int count = Runtime.getRuntime().availableProcessors();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.barrier = new CyclicBarrier(count,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                new Runnable() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    public void run() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        mainBoard.commitNewValues();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }});</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.workers = new Worker[count];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; count; i++)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            workers[i] = new Worker(mainBoard.getSubBoard(count, i));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private class Worker implements Runnable {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        private final Board board;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public Worker(Board board) { this.board = board; }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void run() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            while (!board.hasConverged()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                for (int x = 0; x &lt; board.getMaxX(); x++)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    for (int y = 0; y &lt; board.getMaxY(); y++)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        board.setNewValue(x, y, computeValue(x, y));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    barrier.await();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                } catch (InterruptedException ex) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                } catch (BrokenBarrierException ex) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        private int computeValue(int x, int y) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Compute the new value that goes in (x,y)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return 0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void start() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; workers.length; i++)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            new Thread(workers[i]).start();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        mainBoard.waitForConvergence();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    interface Board {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int getMaxX();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int getMaxY();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int getValue(int x, int y);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int setNewValue(int x, int y, int value);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        void commitNewValues();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        boolean hasConverged();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        void waitForConvergence();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Board getSubBoard(int numPartitions, int index);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>CellularAutomata用于模拟细胞增殖位置，它将问题分为N(=CPU个数)个子线程解决。当这N个子问题都完成计算后(到达栅栏位置)，由栅栏提交这些结果(由最后一个到达的子线程执行)，之后栅栏状态重置，进行下一轮计算。另一种简化形式的栅栏是Exchanger，它只有两个工作线程，用于安全地交换数据。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="构建高效且可伸缩的结果缓存"></a>构建高效且可伸缩的结果缓存<a class="hash-link" href="#构建高效且可伸缩的结果缓存" title="Direct link to heading">#</a></h2><p>作为一种空间换时间的策略，简单的缓存设计可能将性能瓶颈转为可伸缩性瓶颈。首先看一个使用HashMap缓存计算结果的示例：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class Memoizer1 &lt;A, V&gt; implements Computable&lt;A, V&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Map&lt;A, V&gt; cache = new HashMap&lt;A, V&gt;();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Computable&lt;A, V&gt; c;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Memoizer1(Computable&lt;A, V&gt; c) { this.c = c; }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public synchronized V compute(A arg) throws InterruptedException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        V result = cache.get(arg);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (result == null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            result = c.compute(arg);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            cache.put(arg, result);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return result;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">interface Computable &lt;A, V&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    V compute(A arg) throws InterruptedException;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">class ExpensiveFunction implements Computable&lt;String, BigInteger&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public BigInteger compute(String arg) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // after deep thought...</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new BigInteger(arg);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>缓存类Memoizer1实现Computable接口，调用compute方法时首先尝试在其内部HashMap中找到缓存结果，没有找到则计算并返回。由于HashMap不是线程安全的，这里对整个compute方法进行同步。结果是每次只能有一个线程执行compute方法，当某个线程compute执行时间过长时，使用缓存反而会导致总体计算时间增加。对此，改进措施是使用ConcurrentHashMap来代替HashMap，代码如下所示：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class Memoizer2 &lt;A, V&gt; implements Computable&lt;A, V&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Map&lt;A, V&gt; cache = new ConcurrentHashMap&lt;A, V&gt;();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Computable&lt;A, V&gt; c;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Memoizer2(Computable&lt;A, V&gt; c) { this.c = c; }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public V compute(A arg) throws InterruptedException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        V result = cache.get(arg);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (result == null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            result = c.compute(arg);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            cache.put(arg, result);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return result;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>使用ConcurrentHashMap提升了并发度，但是还存在缺陷——两个线程同时调用compute时会计算相同值，这违背了使用缓存的初衷。我们希望能通过某种方式表达线程A正在计算，线程B只需要等待A计算结束然后获取其结果，而FutureTask类恰好能满足这点：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class Memoizer3 &lt;A, V&gt; implements Computable&lt;A, V&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Map&lt;A, Future&lt;V&gt;&gt; cache = new ConcurrentHashMap&lt;A, Future&lt;V&gt;&gt;();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Computable&lt;A, V&gt; c;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Memoizer2(Computable&lt;A, V&gt; c) { this.c = c; }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public V compute(A arg) throws InterruptedException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Future&lt;V&gt; f = cache.get(arg);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (f == null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            Callable&lt;V&gt; eval = new Callable&lt;V&gt;() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                public V call() throws InterruptedException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return c.compute(arg);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            };</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            FutureTask&lt;V&gt; ft = new FutureTask&lt;V&gt;(eval);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            f = ft;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            cache.put(arg, ft);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            ft.run();           // 调用c.compute</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return f.get();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (ExecutionException e) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw launderThrowable(e.getCause());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>相比于Memoizer2，Memoizer3中cache的put操作是异步的，不必等到compute执行完成。这大大减少了线程重复计算的概率，但是仍会发生，究其原因是复合操作(Put-If-Absent)并不是原子的，继续改进的compute代码如下所示：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public V compute(final A arg) throws InterruptedException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (true) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Future&lt;V&gt; f = cache.get(arg);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (f == null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            Callable&lt;V&gt; eval = new Callable&lt;V&gt;() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                public V call() throws InterruptedException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return c.compute(arg);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            };</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            FutureTask&lt;V&gt; ft = new FutureTask&lt;V&gt;(eval);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            f = cache.putIfAbsent(arg, ft);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (f == null) { f = ft; ft.run(); }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return f.get();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (CancellationException e) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            cache.remove(arg, f);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (ExecutionException e) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw LaunderThrowable.launderThrowable(e.getCause());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>使用putIfAbsent方法设置缓存，并且第二次判断f是否为null来防止其他线程已经提交了compute任务，杜绝了重复计算。另外，为了解决<strong>缓存污染</strong>的问题，当get方法发生异常时移除该计算任务缓存。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="总结"></a>总结<a class="hash-link" href="#总结" title="Direct link to heading">#</a></h2><p>以下是对前5章基础知识部分的概念和规则的总结：</p><ol><li>可变状态至关重要，越少的可变状态越容易确保线程安全性</li><li>尽量将变量声明为final，除非它们可变</li><li>不可变对象一定是线程安全的</li><li>封装有助于管理复杂性</li><li>用锁保护可变变量</li><li><strong>当保护同一个不变性条件的所有变量时，要使用同一个锁</strong></li><li><strong>在执行复合操作时要持有锁</strong></li><li>多线程访问同一个可变变量，没有同步机制会出问题</li><li>不要故作聪明地推断不需要同步</li><li>在设计过程中考虑线程安全，或在文档中明确指出它不是线程安全的</li><li>将同步策略文档化</li></ol></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-tags-row row margin-bottom--sm"><div class="col"><b>Tags:</b><ul class="tags_2ga9 padding--none margin-left--sm"><li class="tag_11ep"><a class="tag_1Okp tagRegular_3MiF" href="/docs/tags/java-concurrency">Java Concurrency</a></li><li class="tag_11ep"><a class="tag_1Okp tagRegular_3MiF" href="/docs/tags/reading-notes">ReadingNotes</a></li></ul></div></div><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/kayhaw/kayhaw.github.io/edit/master/website/docs/Java并发编程实战\Java-Concurrency-in-Practice-Chap05.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_13-_"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap04"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 对象的组合</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap06"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">任务执行 »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#同步容器类" class="table-of-contents__link">同步容器类</a><ul><li><a href="#同步容器类的问题" class="table-of-contents__link">同步容器类的问题</a></li><li><a href="#迭代器与concurrentmodificationexception" class="table-of-contents__link">迭代器与ConcurrentModificationException</a></li><li><a href="#隐藏迭代器" class="table-of-contents__link">隐藏迭代器</a></li></ul></li><li><a href="#并发容器" class="table-of-contents__link">并发容器</a><ul><li><a href="#concurrenthashmap" class="table-of-contents__link">ConcurrentHashMap</a></li><li><a href="#额外的原子map操作" class="table-of-contents__link">额外的原子Map操作</a></li><li><a href="#copyonwritearraylist" class="table-of-contents__link">CopyOnWriteArrayList</a></li></ul></li><li><a href="#阻塞队列和生产者-消费者模式" class="table-of-contents__link">阻塞队列和生产者-消费者模式</a><ul><li><a href="#示例桌面搜索" class="table-of-contents__link">示例：桌面搜索</a></li><li><a href="#串行线程封闭" class="table-of-contents__link">串行线程封闭</a></li><li><a href="#双端队列与工作密取" class="table-of-contents__link">双端队列与工作密取</a></li></ul></li><li><a href="#阻塞方法与中断方法" class="table-of-contents__link">阻塞方法与中断方法</a></li><li><a href="#同步工具类" class="table-of-contents__link">同步工具类</a><ul><li><a href="#闭锁" class="table-of-contents__link">闭锁</a></li><li><a href="#futuretask" class="table-of-contents__link">FutureTask</a></li><li><a href="#信号量" class="table-of-contents__link">信号量</a></li><li><a href="#栅栏" class="table-of-contents__link">栅栏</a></li></ul></li><li><a href="#构建高效且可伸缩的结果缓存" class="table-of-contents__link">构建高效且可伸缩的结果缓存</a></li><li><a href="#总结" class="table-of-contents__link">总结</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">读书笔记</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items"><li class="footer__item"><a href="https://www.zhihu.com/people/xiao-ke-dou-7" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>知乎<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/kayhaw" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://gitee.com/kayhaw" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Gitee<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 何轲(Kay Haw). Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.5c7121e2.js"></script>
<script src="/assets/js/main.eedec005.js"></script>
</body>
</html>