<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.6">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Kay Haw&#39;s Blog Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Kay Haw&#39;s Blog Blog Atom Feed">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" integrity="sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc" crossorigin="anonymous"><title data-react-helmet="true">取消与关闭 | Kay Haw&#x27;s Blog</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://kayhaw.github.io/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap07"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="取消与关闭 | Kay Haw&#x27;s Blog"><meta data-react-helmet="true" name="description" content="《Java并发编程》第七章读书笔记"><meta data-react-helmet="true" property="og:description" content="《Java并发编程》第七章读书笔记"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://kayhaw.github.io/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap07"><link data-react-helmet="true" rel="alternate" href="https://kayhaw.github.io/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap07" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://kayhaw.github.io/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap07" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.0138175c.css">
<link rel="preload" href="/assets/js/runtime~main.7b33080d.js" as="script">
<link rel="preload" href="/assets/js/main.9bda434a.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="Kay Haw&#x27;s Blog" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo.svg" alt="Kay Haw&#x27;s Blog" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">Kay Haw&#x27;s Blog</b></a><a class="navbar__item navbar__link navbar__link--active" href="/docs/intro">读书笔记</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/kayhaw" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle toggle_3Zt9 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_31aa"><button class="clean-btn backToTopButton_35hR" type="button"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" href="/docs/intro">读书笔记</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">C++PrimerPlus</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">EffectiveC++</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Learning Akka</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Stream Processing with Apache Flink</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">Java并发编程实战</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap02">线程安全性</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap03">对象的共享</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap04">对象的组合</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap05">基础构建模块</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap06">任务执行</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap07">取消与关闭</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap08">线程池的使用</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap10">避免活跃性危险</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap13">显式锁</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap14">构建自定义的同步工具</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap15">原子变量与非阻塞同步机制</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap16">Java内存模型</a></li></ul></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">深入理解Java虚拟机</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">高性能MySQL</a></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="tocCollapsible_1PrD theme-doc-toc-mobile tocMobile_3Hoh"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>取消与关闭</h1></header><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p>《Java并发编程》第七章读书笔记</p></div></div><p>第6章介绍了任务的创建和启动，绝大多数情况下任务会一直运行到结束。然而，有些时候希望提前结束任务(用户点击取消、应用程序被关闭)，一个行为良好的程序应该能够完善地处理这些失败、关闭和取消等操作，本章讨论如何实现。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="任务取消"></a>任务取消<a class="hash-link" href="#任务取消" title="Direct link to heading">#</a></h2><p><strong>可取消的(Cancellable)</strong>：外部代码能够在某个操作正常完成前将其置为“完成”状态。取消操作的原因：</p><ul><li>用户请求：用户点击取消按钮</li><li>时间限制：超时后取消运行任务</li><li>程序事件：子任务找到答案，取消其他任务</li><li>程序错误：爬虫任务遇到磁盘已满，取消其他任务</li><li>程序关闭</li></ul><p>Java并没有提供安全的抢占方法来停止线程(stop、suspend存在问题)，但存在一些协作式机制来取消线程，例如使用volatile变量作为“已请求取消”的标志：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class PrimeGenerator implements Runnable {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static ExecutorService exec = Executors.newCachedThreadPool();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final List&lt;BigInteger&gt; primes = new ArrayList&lt;BigInteger&gt;();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private volatile boolean cancelled;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void run() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        BigInteger p = BigInteger.ONE;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (!cancelled) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            p = p.nextProbablePrime();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            synchronized (this) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                primes.add(p);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void cancel() { cancelled = true; }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public synchronized List&lt;BigInteger&gt; get() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new ArrayList&lt;BigInteger&gt;(primes);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    static List&lt;BigInteger&gt; aSecondOfPrimes() throws InterruptedException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        PrimeGenerator generator = new PrimeGenerator();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        exec.execute(generator);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            SECONDS.sleep(1);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            generator.cancel();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return generator.get();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>PrimeGenerator是一个素数生成，通过cancelled标志确定是否继续生成下一个素数。aSecondOfPrimes方法提交任务，并在执行1秒后取消。</p><div class="admonition admonition-tip alert alert--success"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="16" viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>取消策略</h5></div><div class="admonition-content"><p>一个任务必须拥有取消策略：详细定义取消操作的How、What、When要素，即其他代码怎么(how)取消该任务</p></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="中断"></a>中断<a class="hash-link" href="#中断" title="Direct link to heading">#</a></h3><p>简单地使用volatile作为取消标志也存在问题，如下代码所示：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class BrokenPrimeProducer extends Thread {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final BlockingQueue&lt;BigInteger&gt; queue;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private volatile boolean cancelled = false;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    BrokenPrimeProducer(BlockingQueue&lt;BigInteger&gt; queue) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.queue = queue;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void run() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            BigInteger p = BigInteger.ONE;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            while (!cancelled)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                queue.put(p = p.nextProbablePrime());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (InterruptedException consumed) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void cancel() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        cancelled = true;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>当生产者在put方法中阻塞时，消费者调用cancel方法，但此时生产者永远无法检测到cancelled标志为false。此时，可以选择中断来实现取消操作：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class PrimeProducer extends Thread {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final BlockingQueue&lt;BigInteger&gt; queue;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    PrimeProducer(BlockingQueue&lt;BigInteger&gt; queue) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.queue = queue;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void run() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            BigInteger p = BigInteger.ONE;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            while (!Thread.currentThread().isInterrupted())</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                queue.put(p = p.nextProbablePrime());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (InterruptedException consumed) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            /* Allow thread to exit */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 将interrupt方法封装在cancel中</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void cancel() { interrupt(); }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>线程中断是一种协作机制，它通知线程在合适情况下停止当前工作，Thread类提供了如下三种方法：</p><ol><li>public void interrupt()：中断目标线程</li><li>public boolean isInterrupted()：返回目标线程中断状态</li><li>public static boolean interrupted()：清除当前线程中断状态(设置为false)并返回之前的状态，这是清除中断状态的唯一方法</li></ol><p>调用interrupt方法并不是意味着立即停止运行线程，只是传递中断请求消息。设计良好的方法应该对中断请求进行处理，设计糟糕的方法忽略中断请求，导致其他代码无法对中断请求进行响应。</p><div class="admonition admonition-tip alert alert--success"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="16" viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>tip</h5></div><div class="admonition-content"><p>通常，中断是实现取消的最合理方式</p></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="中断策略"></a>中断策略<a class="hash-link" href="#中断策略" title="Direct link to heading">#</a></h3><p>任务应该包含取消策略，那对应线程也要包含中断策略。合理的中断策略是尽快退出，在必要时进行清理，通知某个线程所有者已经退出。任务不会在自己拥有的线程中运行，应该小心地保存中断状态，这样拥有线程的代码才能响应中断。检查到中断请求后，任务不需要立即放弃所有操作，可以在完成当前任务后抛出InterruptedException，并且调用Thread.currentThread().interrupt()方法恢复中断状态。</p><div class="admonition admonition-caution alert alert--warning"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"></path></svg></span>caution</h5></div><div class="admonition-content"><p>每个线程有各自的中断策略，别轻易中断线程</p></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="响应中断"></a>响应中断<a class="hash-link" href="#响应中断" title="Direct link to heading">#</a></h3><p>处理中断有两种方式：</p><ol><li>传递中断异常：在方法签名上加上throws InterruptedException，自己什么都不处理</li><li>恢复中断状态：try-catch捕获InterruptedException后，重新调用Thread.currentThread().interrupt()</li></ol><p>对于使用Runnable定义的任务，方式1不可行，只能通过方式2，例如：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class NoncancelableTask {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Task getNextTask(BlockingQueue&lt;Task&gt; queue) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        boolean interrupted = false;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            while (true) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return queue.take();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                } catch (InterruptedException e) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    interrupted = true;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 重新尝试</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (interrupted)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                Thread.currentThread().interrupt();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="示例计时运行"></a>示例：计时运行<a class="hash-link" href="#示例计时运行" title="Direct link to heading">#</a></h3><p>回顾PrimeGenerator的代码，静态方法aSecondOfPrimes启动一个PrimeGenertor线程，运行1秒后停止，该代码存在的问题是PrimeGenerator运行抛出的异常会被忽略。为了解决异常未捕获的问题，如下代码给出了在指定时间内运行任意一个runnable的示例：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class TimedRun1 {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final ScheduledExecutorService cancelExec = Executors.newScheduledThreadPool(1);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void timedRun(Runnable r, long timeout, TimeUnit unit) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        final Thread taskThread = Thread.currentThread();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 设置一个取消定时任务</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        cancelExec.schedule(new Runnable() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            public void run() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                taskThread.interrupt();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }, timeout, unit);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        r.run();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>该示例直接执行任务r，并设置了一个取消任务，该取消任务在指定时间后中断任务执行。在满足定时运行的要求，任务抛出的异常可以被timedRun方法捕获。这种方法十分简单，但是破坏了规则：<strong>在中断线程前，应该了解它的中断策略</strong>。如果r.run()在timeout前就完成，那么取消任务将会在timedRun返回之后触发，这种行为的后果是未知的(尽管用schedule方法返回的ScheduleFuture来取消任务，但是过于复杂)。并且如果r不响应中断，那timedRun在r结束后返回，此时可能已经超时或者为超时，没有达到限时执行的要求。</p><p>如下代码解决了aSecondOfPrimes的异常处理问题和TimedRun1的问题。执行任务task不响应中断，并将其可能遇到的异常保存在t中，timedRun执行限时的task.join(timeout)方法，因此主线程会定时阻塞到task结束，这里有两种情况：</p><ol><li>task在timeout内结束(正常、异常)，通过rethrow方法重新抛出可能遇到的异常</li><li>task在timeout内还未结束，此时由cancelExec调用task.interrupt()来使其退出</li></ol><p>该方案存在的问题：主线程执行task.rethrow()时，不能确定task是正常退出而返回还是因为join超时而返回。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class TimedRun2 {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final ScheduledExecutorService cancelExec = newScheduledThreadPool(1);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void timedRun(final Runnable r, long timeout, TimeUnit unit) </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    throws InterruptedException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        class RethrowableTask implements Runnable {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            private volatile Throwable t;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            public void run() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    r.run();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                } catch (Throwable t) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    this.t = t;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            void rethrow() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (t != null)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    throw launderThrowable(t);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        RethrowableTask task = new RethrowableTask();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        final Thread taskThread = new Thread(task);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        taskThread.start();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        cancelExec.schedule(new Runnable() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            public void run() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                taskThread.interrupt();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }, timeout, unit);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        taskThread.join(unit.toMillis(timeout));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        task.rethrow();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="通过future来实现取消"></a>通过Future来实现取消<a class="hash-link" href="#通过future来实现取消" title="Direct link to heading">#</a></h3><p>实际上Future已经提供了取消任务的方法cancel，通过Future来取消任务的示例代码如下所示：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class TimedRun {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final ExecutorService taskExec = Executors.newCachedThreadPool();</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void timedRun(Runnable r, long timeout, TimeUnit unit)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            throws InterruptedException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Future&lt;?&gt; task = taskExec.submit(r);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            task.get(timeout, unit);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (TimeoutException e) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 运行超时，到finally块执行任务取消</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (ExecutionException e) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 运行未超时中遇到异常，重新抛出异常</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw launderThrowable(e.getCause());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 调用cancel，即使任务已经结束也不会有任务影响</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 如果任务还在运行，将会被中断</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            task.cancel(true);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>cancel方法接受boolean类型参数mayInterruptIfRunning，为true表示中断正在运行的线程，为false表示不要执行还未运行的线程。</p><div class="admonition admonition-tip alert alert--success"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="16" viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>tip</h5></div><div class="admonition-content"><p>当Future.get()抛出InterruptedException或者TimeoutException时，若不再需要结果可以调用Future.cancel来取消任务</p></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="处理不可中断的阻塞"></a>处理不可中断的阻塞<a class="hash-link" href="#处理不可中断的阻塞" title="Direct link to heading">#</a></h3><p>在Java库中，许多可阻塞的方法都是通过提前返回或者抛出InterruptedException来响应中断请求，但是也存在不可响应中断的阻塞方法：</p><ul><li>Java.io包中的同步Socket IO</li><li>Java.io包中的同步IO</li><li>Selector的异步IO</li><li>获取某个锁</li></ul><p>如下代码给出如何封装非标准的取消操作，ReaderThread重写了Thread.interrupt()方法，通过关闭socket来使得执行read或者write的方法抛出SocketException。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class ReaderThread extends Thread {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final int BUFSZ = 512;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Socket socket;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final InputStream in;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ReaderThread(Socket socket) throws IOException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.socket = socket;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.in = socket.getInputStream();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void interrupt() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            socket.close();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (IOException ignored) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            super.interrupt();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void run() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            byte[] buf = new byte[BUFSZ];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            while (true) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                int count = in.read(buf);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (count &lt; 0)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                else if (count &gt; 0)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    processBuffer(buf, count);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (IOException e) { /* Allow thread to exit */ }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void processBuffer(byte[] buf, int count) {}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="admonition admonition-tip alert alert--success"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="16" viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>tip</h5></div><div class="admonition-content"><p>重写线程的interrupt方法，关闭IO流使阻塞方法抛出异常，同时调用super.interrupt方法保证原来的中断逻辑。</p></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="用newtaskfor来封装非标准的取消"></a>用newTaskFor来封装非标准的取消<a class="hash-link" href="#用newtaskfor来封装非标准的取消" title="Direct link to heading">#</a></h3><p>还可以通过重写newTaskFor来进一步封装上面的非标准取消代码。当把一个Callable通过submit方法提交给ExecutorService时，submit方法通过调用newTaskFor方法得到一个Future(提供取消方法cancel)，并将其返回。因此，可以通过定制Future改变Future.cancel的行为，代码如下所示：</p><details class="details_2Ziz alert alert--info details_1VDD" data-collapsed="true"><summary>通过newTaskFor封装非标准的取消操作</summary><div><div class="collapsibleContent_3OHp"><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public abstract class SocketUsingTask &lt;T&gt; implements CancellableTask&lt;T&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Socket socket;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected synchronized void setSocket(Socket s) { socket = s; }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public synchronized void cancel() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (socket != null)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                socket.close();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (IOException ignored) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public RunnableFuture&lt;T&gt; newTask() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new FutureTask&lt;T&gt;(this) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            public boolean cancel(boolean mayInterruptIfRunning) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    SocketUsingTask.this.cancel();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                } finally {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return super.cancel(mayInterruptIfRunning);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">interface CancellableTask &lt;T&gt; extends Callable&lt;T&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    void cancel();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    RunnableFuture&lt;T&gt; newTask();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">class CancellingExecutor extends ThreadPoolExecutor {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public CancellingExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public CancellingExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public CancellingExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, handler);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public CancellingExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (callable instanceof CancellableTask)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return ((CancellableTask&lt;T&gt;) callable).newTask();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        else</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return super.newTaskFor(callable);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div></div></div></details><p>SocketUsingTask实现了CancellableTask接口，并重写了Future.cancel方法来关闭socket和调用super.cancel。通过调用SocketUsingTask的cancel方法同时关闭底层socket并且中断线程。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="停止基于线程的服务"></a>停止基于线程的服务<a class="hash-link" href="#停止基于线程的服务" title="Direct link to heading">#</a></h2><p>对于持有线程的服务，服务的存在时间往往大于创建线程的存在时间，此时需要服务提供线程生命周期方法。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="示例日志服务"></a>示例：日志服务<a class="hash-link" href="#示例日志服务" title="Direct link to heading">#</a></h3><p>如下所示代码给出了一个简单的日志服务示例，它是一个多生产者单消费者的设计方式。要停止日志线程，一种方式是在LoggerThread的run方法InterruptedException处理块中退出。然而，可能队列中有剩余日志不会被打印，并且仅是日志线程终止，其他调用log方法生产日志的线程会被阻塞。即<strong>取消生产者-消费者操作时，要同时取消生产者和消费者</strong>，现在中断LoggerThread线程会关闭消费者，但生产者并不是专门的线程，任何获取LogWriter引用的线程都可以作为生产者。由于不确定将来会有哪些线程打印日志，要取消它们将十分困难。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class LogWriter {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final BlockingQueue&lt;String&gt; queue;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final LoggerThread logger;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final int CAPACITY = 1000;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public LogWriter(Writer writer) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.queue = new LinkedBlockingQueue&lt;String&gt;(CAPACITY);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.logger = new LoggerThread(writer);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void start() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        logger.start();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void log(String msg) throws InterruptedException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        queue.put(msg);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private class LoggerThread extends Thread {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        private final PrintWriter writer;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public LoggerThread(Writer writer) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.writer = new PrintWriter(writer, true); // autoflush</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void run() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                while (true)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    writer.println(queue.take());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (InterruptedException ignored) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            } finally {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                writer.close();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>另一种关闭线程的方式是设置“关闭标志”，当标志位isShutDown为true并且剩余日志为0时，消费者才可以关闭。注意在多线程环境下，这种“先判断后运行”的复合操作都需要使用同步确保安全。最终代码如下所示：</p><details class="details_2Ziz alert alert--info details_1VDD" data-collapsed="true"><summary>可靠的LogWriter取消操作</summary><div><div class="collapsibleContent_3OHp"><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class LogService {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final BlockingQueue&lt;String&gt; queue;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final LoggerThread loggerThread;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final PrintWriter writer;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private boolean isShutdown;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int reservations;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public LogService(Writer writer) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.queue = new LinkedBlockingQueue&lt;String&gt;();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.loggerThread = new LoggerThread();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.writer = new PrintWriter(writer);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void start() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        loggerThread.start();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void stop() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        synchronized (this) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            isShutdown = true;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        loggerThread.interrupt();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void log(String msg) throws InterruptedException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        synchronized (this) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (isShutdown)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                throw new IllegalStateException(/*...*/);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            ++reservations;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        queue.put(msg);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private class LoggerThread extends Thread {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void run() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                while (true) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        synchronized (LogService.this) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                            if (isShutdown &amp;&amp; reservations == 0)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        String msg = queue.take();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        synchronized (LogService.this) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                            --reservations;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        writer.println(msg);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } catch (InterruptedException e) { /* retry */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            } finally {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                writer.close();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div></div></div></details><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="关闭executorservice"></a>关闭ExecutorService<a class="hash-link" href="#关闭executorservice" title="Direct link to heading">#</a></h3><p>在上一节提到ExecutorService中的shutdown和shutdownNow方法可以关闭任务，基于实现的日志程序如下所示：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class LogService {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final ExecutorService exec = new SingleThreadExecutor();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final PrintWriter writer;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void start() {}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void stop() throws InterruptedException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            exec.shutdown();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            exec.awaitTermination(TIMEOUT, UNIT);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            writer.close();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void log(String msg) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            exec.execute(new WriterTask(msg));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (RejectedExecutionException ignored) {}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="毒丸对象"></a>“毒丸”对象<a class="hash-link" href="#毒丸对象" title="Direct link to heading">#</a></h3><p>另一种关闭生产者-消费者服务的方式是使用“毒丸”对象：当从队列中取到该对象时立即停止。示例代码如下所示：</p><details class="details_2Ziz alert alert--info details_1VDD" data-collapsed="true"><summary>使用“毒丸”对象关闭一对一生产者-消费者服务</summary><div><div class="collapsibleContent_3OHp"><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class IndexingService {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final int CAPACITY = 1000;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final File POISON = new File(&quot;&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final IndexerThread consumer = new IndexerThread();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final CrawlerThread producer = new CrawlerThread();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final BlockingQueue&lt;File&gt; queue;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final FileFilter fileFilter;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final File root;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    class CrawlerThread extends Thread {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void run() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                crawl(root);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (InterruptedException e) { /* fall through */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            } finally {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                while (true) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        queue.put(POISON);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } catch (InterruptedException e1) { /* retry */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        private void crawl(File root) throws InterruptedException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            File[] entries = root.listFiles(fileFilter);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (entries != null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                for (File entry : entries) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (entry.isDirectory())</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        crawl(entry);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    else if (!alreadyIndexed(entry))</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        queue.put(entry);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    class IndexerThread extends Thread {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void run() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                while (true) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    File file = queue.take();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (file == POISON)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    else</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        indexFile(file);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (InterruptedException consumed) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void indexFile(File file) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            /*...*/</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void start() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        producer.start();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        consumer.start();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void stop() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        producer.interrupt();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void awaitTermination() throws InterruptedException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        consumer.join();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div></div></div></details><div class="admonition admonition-caution alert alert--warning"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"></path></svg></span>注意事项</h5></div><div class="admonition-content"><ul><li>“毒丸”对于适用于1:N或N:1的生产者-消费者服务，多对多的场景将难以使用</li><li>只有在无界队列中，“毒丸”对象才能可靠工作</li></ul></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="示例只执行一次的服务"></a>示例：只执行一次的服务<a class="hash-link" href="#示例只执行一次的服务" title="Direct link to heading">#</a></h3><p>如果某个方法需要处理一批任务，并且当所有任务完成后才返回，此时通过一个统一的Exectuor来简化服务周期管理。如下所示代码：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class CheckForMail {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean checkMail(Set&lt;String&gt; hosts, long timeout, TimeUnit unit)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            throws InterruptedException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        ExecutorService exec = Executors.newCachedThreadPool();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        final AtomicBoolean hasNewMail = new AtomicBoolean(false);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (final String host : hosts)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                exec.execute(new Runnable() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    public void run() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        if (checkMail(host))</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                            hasNewMail.set(true);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                });</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            exec.shutdown();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            exec.awaitTermination(timeout, unit);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return hasNewMail.get();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="shutdownnow的局限性"></a>shutdownNow的局限性<a class="hash-link" href="#shutdownnow的局限性" title="Direct link to heading">#</a></h3><p>shutdownNow方法尝试取消正在执行的任务，并返回所有已提交但未执行的任务，但是它并不能返回关闭时正在运行的任务。如下TrackingExecutor类给出了如何在关闭时判断正在执行的任务：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class TrackingExecutor extends AbstractExecutorService {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final ExecutorService exec;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Set&lt;Runnable&gt; tasksCancelledAtShutdown =</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            Collections.synchronizedSet(new HashSet&lt;Runnable&gt;());</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public TrackingExecutor(ExecutorService exec) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.exec = exec;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ... 其他方法委托给exec</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public List&lt;Runnable&gt; getCancelledTasks() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!exec.isTerminated())</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new IllegalStateException(/*...*/);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new ArrayList&lt;Runnable&gt;(tasksCancelledAtShutdown);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void execute(final Runnable runnable) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        exec.execute(new Runnable() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            public void run() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    runnable.run();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                } finally {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (isShutdown()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                            &amp;&amp; Thread.currentThread().isInterrupted())</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        tasksCancelledAtShutdown.add(runnable);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>在使用TrackingExecutor类时要注意潜在的误报问题：任务执行完最后一条指令和线程池将其标记为“结束”之间关闭线程池时，被认为取消的任务实际上已经完成。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="处理非正常的线程终止"></a>处理非正常的线程终止<a class="hash-link" href="#处理非正常的线程终止" title="Direct link to heading">#</a></h2><p>并发程序的某个线程发生故障，异常报错不易发现，程序可能看起来依然在工作。导致线程提前死亡的最主要因素是RuntimeException，这些异常通常不会被捕获，也不会在调用栈中逐层传递。在使用Runnable抽象调用代码时，可以使用try-catch来捕获异常：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public void run() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Throwable thrown = null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        while(!isInterrupted()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            runTask(getTaskFromWorkQueue());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }catch(Throwable e) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            thrown = e;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            threadExited(this, thrown);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>除了主动地使用try-cathch来捕获为检查异常，Thread API也提供了UncaughtExceptionHandler来处理未捕获异常。如下所示，处理未捕获异常的方式是打印到日志。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class UEHLogger implements Thread.UncaughtExceptionHandler {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void uncaughtException(Thread t, Throwable e) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Logger logger = Logger.getAnonymousLogger();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        logger.log(Level.SEVERE, &quot;Thread terminated with exception: &quot; + t.getName(), e);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>在ThreadPoolExecutor的构造函数中提供一个ThreadFactory，就可以为线程池的所有线程设置一个UncaughtExceptionHandler。如果需要在任务因异常而失败时执行特定操作，可以将任务封装在能捕获异常的Runnable或Callable中，或者改写ThreadPoolExecutor的afterExecute方法。</p><div class="admonition admonition-danger alert alert--danger"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="16" viewBox="0 0 12 16"><path fill-rule="evenodd" d="M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"></path></svg></span>小心</h5></div><div class="admonition-content"><p>只有通过executr提交的任务，才能将它抛出的异常交给未捕获异常处理器，而通过submit提交的任务，无论抛出异常是否检查，会被Future.get封装在ExecutionException中重新抛出。</p></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="jvm关闭"></a>JVM关闭<a class="hash-link" href="#jvm关闭" title="Direct link to heading">#</a></h2><p>JVM关闭的方式包括：最后一个非守护线程结束、调用System.exit()、发送SIGINT信号或者Ctrl-C，也可以通过Runtime.halt或者发送SIGKILL来强行关闭JVM。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="关闭钩子"></a>关闭钩子<a class="hash-link" href="#关闭钩子" title="Direct link to heading">#</a></h3><p>在正常关闭中，JVM首先执行所有注册的关闭钩子(Shutdown Hook)。关闭钩子指通过Runtime.addShutdownHook注册但<strong>未开始</strong>的线程，JVM不保证关闭钩子的执行顺序，如果有线程仍在运行，关闭钩子和它们并发执行。当强行关闭时，只是关闭JVM而不会运行关闭钩子。</p><p>在编写关闭钩子时要注意确保其是线程安全的，不应该对程序状态和JVM关闭原因做出任何假设。最后，关闭钩子必须尽快退出，否则JVM退出时间太长影响用户体验。关闭钩子可以用于实现服务或应用的清理工作，例如删除临时文件。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="守护线程"></a>守护线程<a class="hash-link" href="#守护线程" title="Direct link to heading">#</a></h3><p>线程可分为普通线程和守护线程两种，线程退出时JVM会检查其他线程，如果只剩守护线程JVM会正常退出，这些守护线程都会被直接抛弃。守护线程最好用于执行“内部”任务，例如周期性地从内存的缓存中移除逾期的数据。</p><div class="admonition admonition-caution alert alert--warning"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"></path></svg></span>注意</h5></div><div class="admonition-content"><p>守护线程通常不能用于替代程序来管理服务的生命周期。</p></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="终结器"></a>终结器<a class="hash-link" href="#终结器" title="Direct link to heading">#</a></h3><p>垃圾回收器会自动收集不需要的内存资源，对于特殊的资源，如文件句柄和套接字句柄，还需要显式地交还给操作系统。为了实现这个功能，垃圾回收器在释放对象后还会调用它们的finalize方法(终结器)。通常使用finally块和close方法来释放这些资源，而不要使用终结器，除非资源是通过本地方法获得的。</p><div class="admonition admonition-caution alert alert--warning"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"></path></svg></span>注意</h5></div><div class="admonition-content"><p>避免使用终结器</p></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="总结"></a>总结<a class="hash-link" href="#总结" title="Direct link to heading">#</a></h2><ul><li>Java提供协作式的中断机制来取消线程</li><li>基于Future和Executor框架可以快速构建可取消的任务</li></ul></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-tags-row row margin-bottom--sm"><div class="col"><b>Tags:</b><ul class="tags_2ga9 padding--none margin-left--sm"><li class="tag_11ep"><a class="tag_1Okp tagRegular_3MiF" href="/docs/tags/java-concurrency">Java Concurrency</a></li><li class="tag_11ep"><a class="tag_1Okp tagRegular_3MiF" href="/docs/tags/reading-notes">ReadingNotes</a></li></ul></div></div><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/kayhaw/kayhaw.github.io/edit/master/website/docs/Java并发编程实战\Java-Concurrency-in-Practice-Chap07.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_13-_"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap06"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 任务执行</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap08"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">线程池的使用 »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#任务取消" class="table-of-contents__link">任务取消</a><ul><li><a href="#中断" class="table-of-contents__link">中断</a></li><li><a href="#中断策略" class="table-of-contents__link">中断策略</a></li><li><a href="#响应中断" class="table-of-contents__link">响应中断</a></li><li><a href="#示例计时运行" class="table-of-contents__link">示例：计时运行</a></li><li><a href="#通过future来实现取消" class="table-of-contents__link">通过Future来实现取消</a></li><li><a href="#处理不可中断的阻塞" class="table-of-contents__link">处理不可中断的阻塞</a></li><li><a href="#用newtaskfor来封装非标准的取消" class="table-of-contents__link">用newTaskFor来封装非标准的取消</a></li></ul></li><li><a href="#停止基于线程的服务" class="table-of-contents__link">停止基于线程的服务</a><ul><li><a href="#示例日志服务" class="table-of-contents__link">示例：日志服务</a></li><li><a href="#关闭executorservice" class="table-of-contents__link">关闭ExecutorService</a></li><li><a href="#毒丸对象" class="table-of-contents__link">“毒丸”对象</a></li><li><a href="#示例只执行一次的服务" class="table-of-contents__link">示例：只执行一次的服务</a></li><li><a href="#shutdownnow的局限性" class="table-of-contents__link">shutdownNow的局限性</a></li></ul></li><li><a href="#处理非正常的线程终止" class="table-of-contents__link">处理非正常的线程终止</a></li><li><a href="#jvm关闭" class="table-of-contents__link">JVM关闭</a><ul><li><a href="#关闭钩子" class="table-of-contents__link">关闭钩子</a></li><li><a href="#守护线程" class="table-of-contents__link">守护线程</a></li><li><a href="#终结器" class="table-of-contents__link">终结器</a></li></ul></li><li><a href="#总结" class="table-of-contents__link">总结</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">读书笔记</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items"><li class="footer__item"><a href="https://www.zhihu.com/people/xiao-ke-dou-7" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>知乎<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/kayhaw" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://gitee.com/kayhaw" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Gitee<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 何轲(Kay Haw). Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.7b33080d.js"></script>
<script src="/assets/js/main.9bda434a.js"></script>
</body>
</html>