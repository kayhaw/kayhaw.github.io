<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.6">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Kay Haw&#39;s Blog Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Kay Haw&#39;s Blog Blog Atom Feed">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" integrity="sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc" crossorigin="anonymous"><title data-react-helmet="true">原子变量与非阻塞同步机制 | Kay Haw&#x27;s Blog</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://kayhaw.github.io/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap15"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="原子变量与非阻塞同步机制 | Kay Haw&#x27;s Blog"><meta data-react-helmet="true" name="description" content="《Java并发编程》第十五章读书笔记"><meta data-react-helmet="true" property="og:description" content="《Java并发编程》第十五章读书笔记"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://kayhaw.github.io/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap15"><link data-react-helmet="true" rel="alternate" href="https://kayhaw.github.io/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap15" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://kayhaw.github.io/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap15" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.0138175c.css">
<link rel="preload" href="/assets/js/runtime~main.ed6f7924.js" as="script">
<link rel="preload" href="/assets/js/main.87f14a62.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="Kay Haw&#x27;s Blog" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo.svg" alt="Kay Haw&#x27;s Blog" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">Kay Haw&#x27;s Blog</b></a><a class="navbar__item navbar__link navbar__link--active" href="/docs/intro">读书笔记</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/kayhaw" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle toggle_3Zt9 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_31aa"><button class="clean-btn backToTopButton_35hR" type="button"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" href="/docs/intro">读书笔记</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">C++PrimerPlus</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">EffectiveC++</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Learning Akka</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Stream Processing with Apache Flink</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">Java并发编程实战</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap02">线程安全性</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap03">对象的共享</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap04">对象的组合</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap05">基础构建模块</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap06">任务执行</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap07">取消与关闭</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap08">线程池的使用</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap10">避免活跃性危险</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap13">显式锁</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap14">构建自定义的同步工具</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap15">原子变量与非阻塞同步机制</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap16">Java内存模型</a></li></ul></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">深入理解Java虚拟机</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">高性能MySQL</a></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="tocCollapsible_1PrD theme-doc-toc-mobile tocMobile_3Hoh"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>原子变量与非阻塞同步机制</h1></header><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p>《Java并发编程》第十五章读书笔记</p></div></div><p>JUC工具类提供比synchronized更好的性能和可伸缩性，本章介绍性能提升的来源：原子变量与非阻塞同步机制</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="锁的劣势"></a>锁的劣势<a class="hash-link" href="#锁的劣势" title="Direct link to heading">#</a></h2><p>在并发程序中，未获得锁的线程需要经历挂起和恢复的过程，这由JVM借助于操作系统完成。当锁存在竞争激烈时，大量的CPU时间花费在线程调度上而不是实际工作。锁还存在<strong>优先级反转</strong>问题：持有锁的低优先级线程被延迟执行，导致等待锁的高优先级线程无法继续执行。即使忽略这个问题，在细粒度操作上使用锁也是一种高开销，需要一种类似volatile变量的机制来管理线程。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="硬件对并发的支持"></a>硬件对并发的支持<a class="hash-link" href="#硬件对并发的支持" title="Direct link to heading">#</a></h2><p>独占锁是一种悲观技术，它确保没有其他线程干扰才执行。而对于细粒度操作，使用冲突检查机制的乐观锁更加高效。在现代处理器中提供了原子的读-改-写指令，例如比较并交换(Compare-and-Swap)、关联加载/条件存储(Load-Linked/Store-Conditional)，通过这些指令，JVM从硬件上来实现锁和并发数据结构。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="比较并交换"></a>比较并交换<a class="hash-link" href="#比较并交换" title="Direct link to heading">#</a></h3><p>CAS指令包含3个操作数(读写内存位置V，旧值A和新值B)，其语义为：当且仅当V的值为A时将其原子更新为B，否则不执行任何操作。如下代码通过内置锁模拟CAS操作：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class SimulatedCAS {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int value;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public synchronized int get() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return value;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public synchronized int compareAndSwap(int expectedValue, int newValue) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int oldValue = value;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (oldValue == expectedValue)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            value = newValue;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return oldValue;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public synchronized boolean compareAndSet(int expectedValue, int newValue) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return (expectedValue == compareAndSwap(expectedValue, newValue));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>多个线程执行CAS操作只有一个会成功，但是其他线程不会被挂起而是继续尝试，从而在不用锁的情况下实现原子的读-改-写操作。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="非阻塞的计数器"></a>非阻塞的计数器<a class="hash-link" href="#非阻塞的计数器" title="Direct link to heading">#</a></h3><p>如下所示代码通过CAS操作实现一个线程安全的计数器。当线程竞争程度不高时，基于CAS的计数器优于基于锁，在没有竞争时甚至更高。从表面代码看，CAS似乎比内置锁更复杂，但JVM管理锁需要遍历复杂的代码逻辑，可能导致操作系统级的锁定、线程挂起和上下文切换，而CAS不需要。CAS的主要缺点是让调用者处理竞争问题(重试、回退、放弃)，而锁机制会自动处理。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class CasCounter {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private SimulatedCAS value;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int getValue() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return value.get();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int increment() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int v;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        do {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            v = value.get();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } while (v != value.compareAndSwap(v, v + 1));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return v + 1;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="jvm对cas的支持"></a>JVM对CAS的支持<a class="hash-link" href="#jvm对cas的支持" title="Direct link to heading">#</a></h3><p>自Java 5.0引入底层支持，由JVM编译为底层硬件指令，如果底层平台不支持CAS将使用自旋锁，JUC下的AtomicXxx类使用了这些底层支持。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="原子变量类"></a>原子变量类<a class="hash-link" href="#原子变量类" title="Direct link to heading">#</a></h2><p>原子变量类将竞争缩小到单个变量上，JUC提供12个原子变量类，可分为4组：标量类、更新器类、数组类以及复合变量类。常用的是标量类(AtomicInteger、AtomicLong、AtomicBoolean和AtomicReference)，其他基本类型可以进行类型转化(如floatToIntBits、doubleToLongBits)来实现模拟。</p><p>原子标量类扩展Number类，但是没有扩展基本类型的包装类，实际上也无法扩展。同时原子变量类没有重新定义hashCode或者equals方法，因此不适合作为Map容器的键值。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="原子变量类是一种更好的volatile"></a>原子变量类是一种更好的volatile<a class="hash-link" href="#原子变量类是一种更好的volatile" title="Direct link to heading">#</a></h3><p>在第4章中的NumberRange类中，由于存在下界小于上界的不变性条件，仅仅使用volatile或者原子类的上下界都是有问题的。如下所示代码通过原子引用类更新来避免静态条件：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class CasNumberRange {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 私有静态内部类</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static class IntPair {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 不变性条件: lower &lt;= upper</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        final int lower;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        final int upper;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public IntPair(int lower, int upper) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.lower = lower;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.upper = upper;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final AtomicReference&lt;IntPair&gt; values =</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            new AtomicReference&lt;IntPair&gt;(new IntPair(0, 0));</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int getLower() { return values.get().lower; }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int getUpper() { return values.get().upper; }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void setLower(int i) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (true) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            IntPair oldv = values.get();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (i &gt; oldv.upper)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                throw new IllegalArgumentException(&quot;Can&#x27;t set lower to &quot; + i + &quot; &gt; upper&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            IntPair newv = new IntPair(i, oldv.upper);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // CAS操作可能失败，因此调用者要使用while-true循环</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (values.compareAndSet(oldv, newv))</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                return;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void setUpper(int i) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (true) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            IntPair oldv = values.get();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (i &lt; oldv.lower)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                throw new IllegalArgumentException(&quot;Can&#x27;t set upper to &quot; + i + &quot; &lt; lower&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            IntPair newv = new IntPair(oldv.lower, i);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (values.compareAndSet(oldv, newv))</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                return;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="性能比较锁与原子变量"></a>性能比较：锁与原子变量<a class="hash-link" href="#性能比较锁与原子变量" title="Direct link to heading">#</a></h3><p>使用ReentrantLock、AtomicInteger分别实现随机数生成器，使用不同数量线程测试，结论如下：</p><ol><li>竞争程度高时，锁的性能略优于原子变量</li><li>竞争程度中等时，原子变量性能是锁性能2倍</li><li>使用ThreadLocal时性能最高，说明只有完全消除竞争，才能实现真正的可伸缩性</li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="非阻塞算法"></a>非阻塞算法<a class="hash-link" href="#非阻塞算法" title="Direct link to heading">#</a></h2><p>非阻塞算法：一个线程的失败或挂起不会导致其他线程失败或挂起
无锁算法：算法的每一个步骤都存在某个线程能执行下去</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="非阻塞的栈"></a>非阻塞的栈<a class="hash-link" href="#非阻塞的栈" title="Direct link to heading">#</a></h3><p>在实现相同功能情况下，使用非阻塞算法比基于锁的更加复杂。如下所示代码通过CAS实现一个非阻塞的栈：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class ConcurrentStack &lt;E&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    AtomicReference&lt;Node&lt;E&gt;&gt; top = new AtomicReference&lt;Node&lt;E&gt;&gt;();</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void push(E item) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;E&gt; newHead = new Node&lt;E&gt;(item);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;E&gt; oldHead;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        do {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            oldHead = top.get();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            newHead.next = oldHead;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } while (!top.compareAndSet(oldHead, newHead));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public E pop() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;E&gt; oldHead;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;E&gt; newHead;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        do {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            oldHead = top.get();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (oldHead == null)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                return null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            newHead = oldHead.next;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } while (!top.compareAndSet(oldHead, newHead));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return oldHead.item;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static class Node &lt;E&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public final E item;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public Node&lt;E&gt; next;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public Node(E item) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.item = item;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>在push和pop方法中使用do-while和CAS，防止在操作过程中因为有其他线程进行出栈入栈操作导致不变性条件被破坏。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="非阻塞的链表"></a>非阻塞的链表<a class="hash-link" href="#非阻塞的链表" title="Direct link to heading">#</a></h3><p>相比于非阻塞的计数器和栈，实现非阻塞的链表更为复杂。为了实现对链表头尾节点的快速访问，需要单独文虎头尾指针。以尾节点为例，倒数第二个节点的next指针和尾指针都指向它。当插入元素时，这两个指针都需要采用原子更新。</p><p>初看起来，这需要执行两个CAS操作，当这两个CAS操作其中一个失败，或者它们执行之间有另一个线程访问，都会出现链表状态不一致的情况。Michael-Scott提出的非阻塞链表算法解决了这个问题，如下给出了链表插入元素的代码实现：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class LinkedQueue &lt;E&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static class Node &lt;E&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        final E item;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        final AtomicReference&lt;LinkedQueue.Node&lt;E&gt;&gt; next;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public Node(E item, LinkedQueue.Node&lt;E&gt; next) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.item = item;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.next = new AtomicReference&lt;LinkedQueue.Node&lt;E&gt;&gt;(next);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final LinkedQueue.Node&lt;E&gt; dummy = new LinkedQueue.Node&lt;E&gt;(null, null);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final AtomicReference&lt;LinkedQueue.Node&lt;E&gt;&gt; head</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            = new AtomicReference&lt;LinkedQueue.Node&lt;E&gt;&gt;(dummy);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final AtomicReference&lt;LinkedQueue.Node&lt;E&gt;&gt; tail</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            = new AtomicReference&lt;LinkedQueue.Node&lt;E&gt;&gt;(dummy);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean put(E item) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        LinkedQueue.Node&lt;E&gt; newNode = new LinkedQueue.Node&lt;E&gt;(item, null);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (true) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            LinkedQueue.Node&lt;E&gt; curTail = tail.get();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            LinkedQueue.Node&lt;E&gt; tailNext = curTail.next.get();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 这个if检查也很关键</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (curTail == tail.get()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (tailNext != null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 队列处于中间状态，推进尾节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    tail.compareAndSet(curTail, tailNext);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 处于稳定状态，尝试插入新节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (curTail.next.compareAndSet(null, newNode)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 插入成功，尝试推进尾节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        tail.compareAndSet(curTail, newNode);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        return true;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>该算法的基本思路是当链表处于中间状态(尾指针的next不为空)时，由当前线程完成尾指针的设置，使链表恢复为稳定状态。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="原子的域更新器"></a>原子的域更新器<a class="hash-link" href="#原子的域更新器" title="Direct link to heading">#</a></h3><p>在ConcurrentLinkedQueue的实际实现与上一小节的LinkedQueue略有区别，如下代码所示，它并没有将Node的next指针声明为AtomicReference类型而是普通的volatile类型，并使用基于反射的AtomicReferenceFieldUpdater来更新：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">private class Node&lt;E&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final E item;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private valatile Node&lt;E&gt; next;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Node(E item) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">private static AtomicReferenceFieldUpdater&lt;Node, Node&gt; nextUpdater</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    = new AtomicReferenceFieldUpdater</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>在ConcurrentLinkedQueue中，通过nextUpdate的compareAndSet来更新next。虽然代码稍微繁琐，但是它免去了每个Node的AtomicReference创建过程，对于频繁创建生命周期短暂的对象的场景，能够降低插入操作的开销。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="aba问题"></a>ABA问题<a class="hash-link" href="#aba问题" title="Direct link to heading">#</a></h3><p>如果内存值由A变为B，再由B变为A，这种情况在某些算法中仍然被认为是发生了变化，但CAS认为没有，这就是ABA问题。一个简单的解决方案是：引入一个版本号，每次更新内存值版本号也更新，同时比较内存值和版本号相同才认为没有发生变化。在JUC中对应的实现是AtomicStampedReference和AtomicmarkableReference类。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="总结"></a>总结<a class="hash-link" href="#总结" title="Direct link to heading">#</a></h2><ol><li>非阻塞算法通过CAS来实现线程安全性</li><li>没有AtomicFloat和AtomicDouble类</li><li>在竞争程度中等情况下，使用原子类性能优于锁</li><li>非阻塞算法的实现更加困难，见ConcurrentLinkedQueue</li><li>CAS存在ABA问题，通过引入版本号解决</li></ol></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-tags-row row margin-bottom--sm"><div class="col"><b>Tags:</b><ul class="tags_2ga9 padding--none margin-left--sm"><li class="tag_11ep"><a class="tag_1Okp tagRegular_3MiF" href="/docs/tags/java-concurrency">Java Concurrency</a></li><li class="tag_11ep"><a class="tag_1Okp tagRegular_3MiF" href="/docs/tags/reading-notes">ReadingNotes</a></li></ul></div></div><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/kayhaw/kayhaw.github.io/edit/master/website/docs/Java并发编程实战\Java-Concurrency-in-Practice-Chap15.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_13-_"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap14"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 构建自定义的同步工具</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap16"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Java内存模型 »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#锁的劣势" class="table-of-contents__link">锁的劣势</a></li><li><a href="#硬件对并发的支持" class="table-of-contents__link">硬件对并发的支持</a><ul><li><a href="#比较并交换" class="table-of-contents__link">比较并交换</a></li><li><a href="#非阻塞的计数器" class="table-of-contents__link">非阻塞的计数器</a></li><li><a href="#jvm对cas的支持" class="table-of-contents__link">JVM对CAS的支持</a></li></ul></li><li><a href="#原子变量类" class="table-of-contents__link">原子变量类</a><ul><li><a href="#原子变量类是一种更好的volatile" class="table-of-contents__link">原子变量类是一种更好的volatile</a></li><li><a href="#性能比较锁与原子变量" class="table-of-contents__link">性能比较：锁与原子变量</a></li></ul></li><li><a href="#非阻塞算法" class="table-of-contents__link">非阻塞算法</a><ul><li><a href="#非阻塞的栈" class="table-of-contents__link">非阻塞的栈</a></li><li><a href="#非阻塞的链表" class="table-of-contents__link">非阻塞的链表</a></li><li><a href="#原子的域更新器" class="table-of-contents__link">原子的域更新器</a></li><li><a href="#aba问题" class="table-of-contents__link">ABA问题</a></li></ul></li><li><a href="#总结" class="table-of-contents__link">总结</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">读书笔记</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items"><li class="footer__item"><a href="https://www.zhihu.com/people/xiao-ke-dou-7" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>知乎<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/kayhaw" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://gitee.com/kayhaw" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Gitee<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 何轲(Kay Haw). Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.ed6f7924.js"></script>
<script src="/assets/js/main.87f14a62.js"></script>
</body>
</html>