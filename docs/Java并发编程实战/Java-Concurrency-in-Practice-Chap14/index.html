<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.6">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Kay Haw&#39;s Blog Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Kay Haw&#39;s Blog Blog Atom Feed">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" integrity="sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc" crossorigin="anonymous"><title data-react-helmet="true">构建自定义的同步工具 | Kay Haw&#x27;s Blog</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://kayhaw.github.io/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap14"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="构建自定义的同步工具 | Kay Haw&#x27;s Blog"><meta data-react-helmet="true" name="description" content="《Java并发编程》第十四章读书笔记"><meta data-react-helmet="true" property="og:description" content="《Java并发编程》第十四章读书笔记"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://kayhaw.github.io/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap14"><link data-react-helmet="true" rel="alternate" href="https://kayhaw.github.io/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap14" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://kayhaw.github.io/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap14" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.0138175c.css">
<link rel="preload" href="/assets/js/runtime~main.ed6f7924.js" as="script">
<link rel="preload" href="/assets/js/main.87f14a62.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="Kay Haw&#x27;s Blog" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo.svg" alt="Kay Haw&#x27;s Blog" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">Kay Haw&#x27;s Blog</b></a><a class="navbar__item navbar__link navbar__link--active" href="/docs/intro">读书笔记</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/kayhaw" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle toggle_3Zt9 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_31aa"><button class="clean-btn backToTopButton_35hR" type="button"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" href="/docs/intro">读书笔记</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">C++PrimerPlus</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">EffectiveC++</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Learning Akka</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Stream Processing with Apache Flink</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">Java并发编程实战</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap02">线程安全性</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap03">对象的共享</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap04">对象的组合</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap05">基础构建模块</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap06">任务执行</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap07">取消与关闭</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap08">线程池的使用</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap10">避免活跃性危险</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap13">显式锁</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap14">构建自定义的同步工具</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap15">原子变量与非阻塞同步机制</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap16">Java内存模型</a></li></ul></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">深入理解Java虚拟机</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">高性能MySQL</a></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="tocCollapsible_1PrD theme-doc-toc-mobile tocMobile_3Hoh"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>构建自定义的同步工具</h1></header><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p>《Java并发编程》第十四章读书笔记</p></div></div><p>介绍实现状态依赖性的各种选择，以及提供状态依赖性机制时需要遵守的规则。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="状态依赖性的管理"></a>状态依赖性的管理<a class="hash-link" href="#状态依赖性的管理" title="Direct link to heading">#</a></h2><p>在单线程环境下，基于状态的前提条件未得到满足，那该条件永远无法成真，此时程序行为按照失败处理。而在多线程环境下，可能经过几条指令后前提条件又改变了。因此，依赖状态的操作可以一直阻塞到前提条件为真再继续执行，这比让它们先失败再实现起来更方便。可阻塞的状态依赖伪代码如下所示：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">获取对象状态的锁</span></span><span class="token-line" style="color:#393A34"><span class="token plain">while(状态的前提条件为假) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  释放锁</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  等到前提条件为真</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  当被中断或者超时可以选择失败退出</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  重新上锁</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">执行操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">释放锁</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>首先构成前提条件的状态变量由锁保护(确保判断时没有其他线程修改状态)，在进行判断，如果为真则执行操作然后释放锁，如果为假则先释放锁再等待前提条件为真，在再次测试前提条件之前都必须重新上锁。</p><p>接下来以有界缓存的不同实现来介绍如何处理前提条件失败的问题。首先给出基类BaseBoundBuffer代码实现，该类实现了一个基于数组的循环缓存，各个状态变量都由内置锁保护。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public abstract class BaseBoundedBuffer &lt;V&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final V[] buf;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int tail;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int head;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int count;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected BaseBoundedBuffer(int capacity) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.buf = (V[]) new Object[capacity];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected synchronized final void doPut(V v) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        buf[tail] = v;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (++tail == buf.length)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            tail = 0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        ++count;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected synchronized final V doTake() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        V v = buf[head];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        buf[head] = null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (++head == buf.length)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            head = 0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        --count;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return v;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public synchronized final boolean isFull() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return count == buf.length;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public synchronized final boolean isEmpty() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return count == 0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="示例将前提条件的失败传递给调用者"></a>示例：将前提条件的失败传递给调用者<a class="hash-link" href="#示例将前提条件的失败传递给调用者" title="Direct link to heading">#</a></h3><p>当使用缓存时，必须遵守“缓存为空不能获取，缓存已满不能添加”的前提规则，当前提规则不满足时，一种简单方法是直接抛出异常，如下所示：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class GrumpyBoundedBuffer &lt;V&gt; extends BaseBoundedBuffer&lt;V&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public GrumpyBoundedBuffer() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this(100);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public GrumpyBoundedBuffer(int size) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        super(size);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public synchronized void put(V v) throws BufferFullException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (isFull())</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new BufferFullException();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        doPut(v);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public synchronized V take() throws BufferEmptyException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (isEmpty())</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new BufferEmptyException();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return doTake();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>此时，每次调用缓存操作的代码必须处理未检查异常并且重复操作直到成功，代码如下所示：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">while (true) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String item = buffer.take();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // use item</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (BufferEmptyException e) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread.sleep(SLEEP_GRANULARITY);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>休眠会降低程序响应性，第二种方式不让调用进入休眠，而是直接重新调用take方法，称之为<strong>忙等待</strong>或者<strong>自旋等待</strong>，但会造成CPU时间浪费。第三种方式是通过Thread.yield方法让出CPU时间片。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="示例通过轮询与休眠来实现简单的阻塞"></a>示例：通过轮询与休眠来实现简单的阻塞<a class="hash-link" href="#示例通过轮询与休眠来实现简单的阻塞" title="Direct link to heading">#</a></h3><p>为了免去调用者一直用while-true循环来实现重试逻辑，改写put和take方法，将前提条件的验证管理封装起来从而简化使用，代码如下所示：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public void put(V v) throws InterruptedException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (true) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        synchronized (this) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!isFull()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                doPut(v);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                return;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread.sleep(SLEEP_GRANULARITY);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public V take() throws InterruptedException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (true) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        synchronized (this) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!isEmpty())</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                return doTake();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread.sleep(SLEEP_GRANULARITY);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>通过synchronized同步块，确保验证前提条件时收到锁保护。若验证失败则释放锁并休眠一段时间，从而确保其他线程能够访问缓存。从调用者角度看，操作要么立即执行，要么阻塞。但这种方式需要注意两点：</p><ul><li>合适的休眠时间，间隔时间越小响应性越高但是CPU消耗也更大</li><li>处理InterruptedException，当等待阻塞方法返回时，通过中断来取消方法执行</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="条件队列"></a>条件队列<a class="hash-link" href="#条件队列" title="Direct link to heading">#</a></h3><p>通过轮序和休眠可以实现阻塞操作，但一种更好的方式是使用条件队列。每个对象都可以作为一个锁，所有等待该锁的线程形成一个条件队列，而Object类的wait、notify和notifyAll方法构成该队列的API。如下代码通过wait和notifyAll方法实现一个有界缓存：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public synchronized void put(V v) throws InterruptedException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (isFull())</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        wait();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    doPut(v);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    notifyAll();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public synchronized V take() throws InterruptedException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (isEmpty())</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        wait();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    V v = doTake();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    notifyAll();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return v;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>通过条件队列，在前提条件为假时使用wait挂起线程，当前提条件为真是使用notifyAll唤醒线程，这比使用休眠的有界缓存更加简单高效。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="使用条件队列"></a>使用条件队列<a class="hash-link" href="#使用条件队列" title="Direct link to heading">#</a></h2><p>条件队列让构建高响应性的状态依赖类更加容易，但它也会被错误使用。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="条件谓词"></a>条件谓词<a class="hash-link" href="#条件谓词" title="Direct link to heading">#</a></h3><p>条件谓词是使某个操作成为状态依赖操作的前提条件，它和锁、wait方法组成条件等待的三要素。条件谓词包含多个状态变量，每个状态变量必须由一个锁来保护，并且锁对象和条件队列对象(调用wait、notify等方法的对象)必须相同。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="过早唤醒"></a>过早唤醒<a class="hash-link" href="#过早唤醒" title="Direct link to heading">#</a></h3><p>由于内置条件队列可以与多个条件谓词一起使用，wait方法返回时并不一定意味着它所等待的条件谓词为真(例如一个线程由于notifyAll而醒来时，wait方法假装返回)。基于这些原因，线程从wait中唤醒时都必须再次测试条件谓词，即标准的条件等待代码模板如下所示：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">void stateDependentMethod() throw InterruptedException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    synchronized(lock) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (!conditionPredicate()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            lock.wait();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>使用条件等待总结：</p><ol><li>通过条件谓词测试</li><li>在调用wait前，从wait返回后都测试</li><li>在while循环中调用wait</li><li>使用条件对象相关锁保护状态变量</li><li>调用wait、notify或者notifyAll时一定要持有与条件队列相关的锁</li><li>检查条件谓词后和开始操作前，都不要释放锁</li></ol><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="信号丢失"></a>信号丢失<a class="hash-link" href="#信号丢失" title="Direct link to heading">#</a></h3><p>信号丢失属于一种活跃性故障：线程等待已经为真的条件，但是开始等待之前没有检查条件谓词。例如在wait方法之前没有检测条件谓词。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="通知"></a>通知<a class="hash-link" href="#通知" title="Direct link to heading">#</a></h3><p>当其他线程等待条件时，一定要确保条件谓词为真后通过某种方式发出通知，对于条件队列来说就是notify和notifyAll方法。notify方法随机唤醒一个线程，而notifyAll方法唤醒所有等待线程。由于多个线程可以基于不同条件谓词等待，使用notify将导致<strong>信号劫持问题</strong>：PB成真，同时线程C执行notify操作，唤醒等待PA的线程A，A发现PA为假继续等待，而等待PB的线程B本该执行但还是等待。因此，只有<strong>同时满足</strong>以下两个条件才能使用notify而不是notifyAll：</p><ol><li>所有等待线程的类型相同：只有一个条件谓词，执行操作相同</li><li>单进单出：通知每次最多唤起一个线程</li></ol><p>大部分类不满足这两点要求，优先使用notifyAll通知唤醒以确保类行为正确。为了优化性能，还可以使用<strong>条件通知</strong>，如下代码所示：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public synchronized void alternatePut(V v) throws InterruptedException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (isFull())</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        wait();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    boolean wasEmpty = isEmpty();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    doPut(v);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (wasEmpty)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        notifyAll();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>单次通知和条件通知可以优化通知性能，但是要遵守“先让程序正确执行，再让程序高效执行”的原则使用。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="示例阀门类"></a>示例：阀门类<a class="hash-link" href="#示例阀门类" title="Direct link to heading">#</a></h3><p>在第5章中的TestHarness类中使用二元闭锁来控制线程开始执行的时刻，但闭锁存在缺陷：它们是一次性的，阀门打开后就无法关闭。如下代码通过条件等待实现一个可重新关闭的ThreadGate类：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class ThreadGate {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // CONDITION-PREDICATE: opened-since(n) (isOpen || generation&gt;n)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private boolean isOpen;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int generation;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public synchronized void close() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        isOpen = false;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 打开阀门，通知所有等待线程</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public synchronized void open() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        ++generation;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        isOpen = true;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        notifyAll();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // BLOCKS-UNTIL: opened-since(generation on entry)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public synchronized void await() throws InterruptedException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int arrivalGeneration = generation;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (!isOpen &amp;&amp; arrivalGeneration == generation)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            wait();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>在await方法中的条件谓词稍微复杂些：如果只检查isOpen，当阀门快速开启又关闭时，所有线程可能都无法释放。通过generation计数器检查，每当阀门开启一次，所有线程都能够通过await。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="子类的安全问题"></a>子类的安全问题<a class="hash-link" href="#子类的安全问题" title="Direct link to heading">#</a></h3><p>对于状态依赖类，要么将其等待和通知等协议完全向子类公开，要么完全阻止子类参与到等待和通知过程。前者至少需要公开条件队列和锁，并将条件谓词和同步策略写入文档。后者可以隐藏条件队列、锁和状态变量(声明为private)，或者直接将类声明为final。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="封装条件队列"></a>封装条件队列<a class="hash-link" href="#封装条件队列" title="Direct link to heading">#</a></h3><p>通常需要把条件队列封装起来，否则调用者会滥用条件队列。然而这种做法与线程安全类的设计模式冲突，该模式建议使用对象的内置锁保护对象自身的状态，例如BoundedBuffer。可以将BoundedBuffer重新设计为使用私有锁对象和条件队列，此时它不再支持客户端加锁。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="入口协议与出口协议"></a>入口协议与出口协议<a class="hash-link" href="#入口协议与出口协议" title="Direct link to heading">#</a></h3><p>入口协议和出口协议是wait和notify方法正确使用的规范。对于每次依赖状态的操作，入口协议是该操作的条件谓词，出口协议包括，检查该操作修改的所有状态变量，确认它们是否改变其他条件谓词，如果是则通知相关条件队列。在AbstractQueuedSynchronizer中使用出口协议，该类并不是由同步器自行执行通知，而是要求同步器方法返回一个值来表示该类的操作是否解除了一个或多个线程的阻塞。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="显式的condition对象"></a>显式的Condition对象<a class="hash-link" href="#显式的condition对象" title="Direct link to heading">#</a></h2><p>内置条件队列存在一些缺陷：每个内置锁只能有一个相关联的条件队列。因此多个线程可能在同一个条件队列上等待不同的条件谓词，并且常见加锁模式会公开条件队列，这些因素都无法满足使用notifyAll时所有等待线程都是同一类型的需求，此时可以使用显示的Lock和Condition。</p><p>正如条件队列和内置锁相关联，Condition和Lock关联在一起，通过Lock.newCondition方法得到Condition对象，并且每次Lock可以拥有任意数量的Codition对象。如下所示代码通过两个Condition给出有界缓存的另一种实现：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class ConditionBoundedBuffer &lt;T&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected final Lock lock = new ReentrantLock();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // CONDITION PREDICATE: notFull (count &lt; items.length)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Condition notFull = lock.newCondition();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // CONDITION PREDICATE: notEmpty (count &gt; 0)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Condition notEmpty = lock.newCondition();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final int BUFFER_SIZE = 100;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final T[] items = (T[]) new Object[BUFFER_SIZE];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int tail, head, count;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // BLOCKS-UNTIL: notFull</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void put(T x) throws InterruptedException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        lock.lock();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            while (count == items.length)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                notFull.await();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            items[tail] = x;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (++tail == items.length)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                tail = 0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            ++count;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            notEmpty.signal();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            lock.unlock();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // BLOCKS-UNTIL: notEmpty</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public T take() throws InterruptedException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        lock.lock();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            while (count == 0)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                notEmpty.await();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            T x = items[head];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            items[head] = null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (++head == items.length)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                head = 0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            --count;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            notFull.signal();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return x;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            lock.unlock();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>使用Lock和Condition时也必须满足锁、条件谓词和条件变量的三元关系，当需要使用公平的队列操作或者每个锁对应多个等待线程队列等高级功能，优先考虑Condition而不是内置条件队列。</p><div class="admonition admonition-caution alert alert--warning"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"></path></svg></span>注意</h5></div><div class="admonition-content"><p>在Condition对象中，与wait、notify和notifyAll对应的方法分别时await、signal和signalAll，同时Condition也继承Object，所以也有wait等方法，但是要调用正确的await方法。</p></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="synchronizer剖析"></a>Synchronizer剖析<a class="hash-link" href="#synchronizer剖析" title="Direct link to heading">#</a></h2><p>ReentrantLock和Semaphore作为同步工具存在许多共同点，如下所示代码用ReentrantLock实现了Semaphore：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class SemaphoreOnLock {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Lock lock = new ReentrantLock();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // CONDITION PREDICATE: permitsAvailable (permits &gt; 0)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Condition permitsAvailable = lock.newCondition();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int permits;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    SemaphoreOnLock(int initialPermits) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        lock.lock();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            permits = initialPermits;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            lock.unlock();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // BLOCKS-UNTIL: permitsAvailable</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void acquire() throws InterruptedException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        lock.lock();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            while (permits &lt;= 0)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                permitsAvailable.await();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            --permits;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            lock.unlock();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void release() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        lock.lock();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            ++permits;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            permitsAvailable.signal();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            lock.unlock();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>反之使用Semaphore实现ReentrantLock也是可行的，但实际上它们都基于AbstractQueuedSynchronizer(AQS)类实现，该类也是JUC下其他同步工具类的实现基础。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="abstractqueuedsynchronizer"></a>AbstractQueuedSynchronizer<a class="hash-link" href="#abstractqueuedsynchronizer" title="Direct link to heading">#</a></h2><p>开发时不会直接使用AQS，因为标准同步工具类能够满足大部分情况。基于AQS的同步工具类中，最基础的是各种形式的获取操作和释放操作。获取操作时一种依赖状态的操作，通常会阻塞，释放操作不会阻塞，释放后所有请求时被阻塞的线程都会开始执行：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">boolean acquire() throw InterruptedException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    while(当前状态不允许获取操作){</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(需要阻塞获取操作) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            如果当前线程不在队列中，将其加入队列</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            阻塞当前线程</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            返回false</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    可能更新同步器状态</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    线程位于队列中，将其移除</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    返回true</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">boolean release() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    更新同步器状态</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if(新状态允许某个被阻塞的线程获取成功)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        解除队列中一个或多个线程的阻塞状态</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>AQS类管理一个整数，用于表示任意状态。比如ReentrantLock用它来表示所有者线程已经重复获取该锁的次数，Semaphore用它来表示剩余的许可数量，FutureTask用它表示任务状态(未开始、正在运行、已完成和已取消)。如下所示代码使用AQS实现一个二元闭锁：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class OneShotLatch {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Sync sync = new Sync();</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void signal() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        sync.releaseShared(0);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void await() throws InterruptedException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        sync.acquireSharedInterruptibly(0);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private class Sync extends AbstractQueuedSynchronizer {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        protected int tryAcquireShared(int ignored) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Succeed if latch is open (state == 1), else fail</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return (getState() == 1) ? 1 : -1;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        protected boolean tryReleaseShared(int ignored) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            setState(1); // Latch is now open</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return true; // Other threads may now be able to acquire</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>oneSlotLatch也可以使用继承AQS的方式实现，但并不推荐，因为它会暴露AQS的公共方法，调用者可能会使用这些公共方法破坏闭锁状态。JUC下的工具类也都没有直接扩展AQS，而是将功能委托给私有的AQS子类。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="juc同步器类中的aqs"></a>JUC同步器类中的AQS<a class="hash-link" href="#juc同步器类中的aqs" title="Direct link to heading">#</a></h2><p>简单介绍ReentrantLock、Semaphore、CountDownLatch等同步器类是如何使用AQS</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="reentrantlock"></a>ReentrantLock<a class="hash-link" href="#reentrantlock" title="Direct link to heading">#</a></h3><p>ReentrantLock只支持独占方式的获取操作，因此实现了tryAcquire、tryRelease和isHeldExclusively方法。如下代码是非公平版本的tryAcquirefangfa方法：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">protected boolean tryAcquire(int ignored) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    final Thread current = Thread.currentThread();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int c = getState();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 没有线程占有，尝试获取锁</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if(c == 0) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 使用CAS修改状态，并返回成功</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(compareAndSetState(0, 1)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            owner = current;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return true;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 当前线程占有，状态计数器加1，返回成功</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else if(current == owner) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        setState(c+1);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return true;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return false;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="semaphore和countdownlatch"></a>Semaphore和CountDownLatch<a class="hash-link" href="#semaphore和countdownlatch" title="Direct link to heading">#</a></h3><p>Semaphore将AQS中的同步状态用于保存当前可用许可证的数量，当许可证数量remaining小于0返回该值，否则使用CAS更新许可证数量。CountDownLatch使用AQS的方式与Semaphore相似，只不过逻辑相反：countDown方法调用AQS的release方法，导致计数器递减，await方法调用AQS的acquire方法，当计数器为零时立即返回，否则阻塞。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">protected int tryAcquireShared(int acquires) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    while(true) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int available = getState();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int remaining = available - acuqires;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 剩余数量小于0，直接返回表示获取失败</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 否则尝试修改state</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(remaining &lt; 0 || compareAndSetState(available, remaining))</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return remaining;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">protected boolean tryReleaseShared(int releases) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // while循环更新state，增加许可证数量</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    while(true) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int p = getState();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(compareAndSetState(p, p + release))</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return true;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="futuretask"></a>FutureTask<a class="hash-link" href="#futuretask" title="Direct link to heading">#</a></h3><p>FutureTask的get方法类似闭锁：某个事件(任务完成或取消)发生时，调用者线程继续执行，否则将停留在队列中直到该事件发生。在FutureTask中，AQS的state用于表示任务状态，此外FutureTask也要维护计算任务抛出的异常或者结果。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="reentrantreadwritelock"></a>ReentrantReadWriteLock<a class="hash-link" href="#reentrantreadwritelock" title="Direct link to heading">#</a></h3><p>ReentrantReadWriteLock并没有使用两个AQS对象来实现读锁和写锁，而是用单个AQS对象同时管理读锁和写锁：state的16位表示写锁的技术，另外16位表示读锁的计数。在读锁上使用共享的获取和释放方法，在写锁上使用独占的获取和释放方法。</p><p>AQS在内部维护一个等待队列，记录请求线程是独占还是共享访问。当锁可用时，如果队列头是写入线程，该线程获得锁，如果队列头是读取线程，队列中第一个写线程之前的读线程都将会获得锁。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="总结"></a>总结<a class="hash-link" href="#总结" title="Direct link to heading">#</a></h2><ol><li>Lock相比于内置锁可以提供公平性选择(公平锁性能弱于非公平锁，一般用不上)，提供等待线程分类管理(通过Condition)等扩展功能</li><li>使用Condition时注意不要调用Object的wait、notify和notifyAll方法</li><li>实现状态依赖类的最好方式是使用现有库中的同步工具类，如果功能还不能满足使用AQS来构建自定义同步器</li></ol></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-tags-row row margin-bottom--sm"><div class="col"><b>Tags:</b><ul class="tags_2ga9 padding--none margin-left--sm"><li class="tag_11ep"><a class="tag_1Okp tagRegular_3MiF" href="/docs/tags/java-concurrency">Java Concurrency</a></li><li class="tag_11ep"><a class="tag_1Okp tagRegular_3MiF" href="/docs/tags/reading-notes">ReadingNotes</a></li></ul></div></div><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/kayhaw/kayhaw.github.io/edit/master/website/docs/Java并发编程实战\Java-Concurrency-in-Practice-Chap14.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_13-_"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap13"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 显式锁</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap15"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">原子变量与非阻塞同步机制 »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#状态依赖性的管理" class="table-of-contents__link">状态依赖性的管理</a><ul><li><a href="#示例将前提条件的失败传递给调用者" class="table-of-contents__link">示例：将前提条件的失败传递给调用者</a></li><li><a href="#示例通过轮询与休眠来实现简单的阻塞" class="table-of-contents__link">示例：通过轮询与休眠来实现简单的阻塞</a></li><li><a href="#条件队列" class="table-of-contents__link">条件队列</a></li></ul></li><li><a href="#使用条件队列" class="table-of-contents__link">使用条件队列</a><ul><li><a href="#条件谓词" class="table-of-contents__link">条件谓词</a></li><li><a href="#过早唤醒" class="table-of-contents__link">过早唤醒</a></li><li><a href="#信号丢失" class="table-of-contents__link">信号丢失</a></li><li><a href="#通知" class="table-of-contents__link">通知</a></li><li><a href="#示例阀门类" class="table-of-contents__link">示例：阀门类</a></li><li><a href="#子类的安全问题" class="table-of-contents__link">子类的安全问题</a></li><li><a href="#封装条件队列" class="table-of-contents__link">封装条件队列</a></li><li><a href="#入口协议与出口协议" class="table-of-contents__link">入口协议与出口协议</a></li></ul></li><li><a href="#显式的condition对象" class="table-of-contents__link">显式的Condition对象</a></li><li><a href="#synchronizer剖析" class="table-of-contents__link">Synchronizer剖析</a></li><li><a href="#abstractqueuedsynchronizer" class="table-of-contents__link">AbstractQueuedSynchronizer</a></li><li><a href="#juc同步器类中的aqs" class="table-of-contents__link">JUC同步器类中的AQS</a><ul><li><a href="#reentrantlock" class="table-of-contents__link">ReentrantLock</a></li><li><a href="#semaphore和countdownlatch" class="table-of-contents__link">Semaphore和CountDownLatch</a></li><li><a href="#futuretask" class="table-of-contents__link">FutureTask</a></li><li><a href="#reentrantreadwritelock" class="table-of-contents__link">ReentrantReadWriteLock</a></li></ul></li><li><a href="#总结" class="table-of-contents__link">总结</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">读书笔记</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items"><li class="footer__item"><a href="https://www.zhihu.com/people/xiao-ke-dou-7" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>知乎<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/kayhaw" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://gitee.com/kayhaw" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Gitee<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 何轲(Kay Haw). Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.ed6f7924.js"></script>
<script src="/assets/js/main.87f14a62.js"></script>
</body>
</html>