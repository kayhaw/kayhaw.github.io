<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.6">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Kay Haw&#39;s Blog Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Kay Haw&#39;s Blog Blog Atom Feed">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" integrity="sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc" crossorigin="anonymous"><title data-react-helmet="true">线程池的使用 | Kay Haw&#x27;s Blog</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://kayhaw.github.io/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap08"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="线程池的使用 | Kay Haw&#x27;s Blog"><meta data-react-helmet="true" name="description" content="《Java并发编程》第八章读书笔记"><meta data-react-helmet="true" property="og:description" content="《Java并发编程》第八章读书笔记"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://kayhaw.github.io/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap08"><link data-react-helmet="true" rel="alternate" href="https://kayhaw.github.io/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap08" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://kayhaw.github.io/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap08" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.0138175c.css">
<link rel="preload" href="/assets/js/runtime~main.7de17fe8.js" as="script">
<link rel="preload" href="/assets/js/main.00935a8a.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="Kay Haw&#x27;s Blog" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo.svg" alt="Kay Haw&#x27;s Blog" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">Kay Haw&#x27;s Blog</b></a><a class="navbar__item navbar__link navbar__link--active" href="/docs/intro">读书笔记</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/kayhaw" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle toggle_3Zt9 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_31aa"><button class="clean-btn backToTopButton_35hR" type="button"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" href="/docs/intro">读书笔记</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">C++PrimerPlus</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">EffectiveC++</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Learning Akka</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">Java并发编程实战</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap02">线程安全性</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap03">对象的共享</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap04">对象的组合</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap05">基础构建模块</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap06">任务执行</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap07">取消与关闭</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap08">线程池的使用</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap10">避免活跃性危险</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap13">显式锁</a></li></ul></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">深入理解Java虚拟机</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">高性能MySQL</a></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="tocCollapsible_1PrD theme-doc-toc-mobile tocMobile_3Hoh"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>线程池的使用</h1></header><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p>《Java并发编程》第八章读书笔记</p></div></div><p>介绍线程池配置和调优的高级选项，以及使用时需要注意的地方</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="在任务与执行策略之间的隐性耦合"></a>在任务与执行策略之间的隐性耦合<a class="hash-link" href="#在任务与执行策略之间的隐性耦合" title="Direct link to heading">#</a></h2><p>Executor框架将任务的提交与执行策略解耦，但是并非所有任务都能适用所有的执行策略，以下类型任务需要明确地指定执行策略：</p><ul><li>依赖性任务：当提交任务依赖其他任务时，给执行策略带来了隐含的限制</li><li>使用线程封闭的任务：使用线程封闭的任务要求Executor是单线程，否则会失去线程安全性</li><li>响应时间敏感的任务：如GUI程序</li><li>使用ThreadLocal的任务：只有当线程本地值生命周期受限于任务生命周期，使用ThreadLocal才有意义，而在线程池中的线程不符合这点</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="线程饥饿死锁"></a>线程饥饿死锁<a class="hash-link" href="#线程饥饿死锁" title="Direct link to heading">#</a></h3><p>当线程池中的任务需要无限期地等待池中其他等待任务提供的资源时，将发生线程饥饿死锁(Thread Starvation Deadlock)，如下所示代码是一个示例：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class ThreadDeadlock {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ExecutorService exec = Executors.newSingleThreadExecutor();</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public class RenderPageTask implements Callable&lt;String&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public String call() throws Exception {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            Future&lt;String&gt; header, footer;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            header = exec.submit(new LoadFileTask(&quot;header.html&quot;));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            footer = exec.submit(new LoadFileTask(&quot;footer.html&quot;));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            String page = renderBody();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Will deadlock -- task waiting for result of subtask</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return header.get() + page + footer.get();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>当使用单线程的Executor会导致ThreadDeadlock发生死锁，类似地，当线程池不够大，通过栅栏机制协同的任务也会出现死锁。除了显式的线程池大小导致死锁，还可能存在其他资源约束隐式地导致死锁，比入JDBC连接池值包含10个连接，此时线程池大小也表现得限于10，因为其他线程需要获得JDBC连接。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="运行时间较长的任务"></a>运行时间较长的任务<a class="hash-link" href="#运行时间较长的任务" title="Direct link to heading">#</a></h3><p>如果线程池大小远小于在稳定状态下执行时间较长的任务数量，最后可能所有线程都运行这些耗时长的任务，影响总体的响应性。一种缓解方式是限定等待资源的时间，等待超时后可以终止任务或者重新放回队列。当线程池总是充满被阻塞的线程时，也可能是线程池规模过小。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="设置线程池"></a>设置线程池<a class="hash-link" href="#设置线程池" title="Direct link to heading">#</a></h2><p>线程池大小不能在代码中固定，应该由配置机制来提供，或者根据CPU数量来动态计算。对于计算密集型任务，通常设置线程池大小为<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mrow><mi>c</mi><mi>p</mi><mi>u</mi></mrow></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N_{cpu}+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">u</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em"></span><span class="mord">1</span></span></span></span></span>，对于IO密集型任务，给出如下定义：</p><ul><li><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mrow><mi>c</mi><mi>p</mi><mi>u</mi></mrow></msub></mrow><annotation encoding="application/x-tex">N_{cpu}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">u</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em"><span></span></span></span></span></span></span></span></span></span></span>：CPU数量</li><li><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mrow><mi>c</mi><mi>p</mi><mi>u</mi></mrow></msub></mrow><annotation encoding="application/x-tex">U_{cpu}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">u</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em"><span></span></span></span></span></span></span></span></span></span></span>：目标CPU利用率</li><li><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>W</mi><mi>C</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{W}{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em"><span style="top:-2.6550000000000002em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em">C</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:0.04em"></span></span><span style="top:-3.394em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em">W</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>：等待时间/计算时间</li></ul><p>要达到目标利用率，线程池的大小应设置为：<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mrow><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>d</mi><mi>s</mi></mrow></msub><mo>=</mo><msub><mi>N</mi><mrow><mi>c</mi><mi>p</mi><mi>u</mi></mrow></msub><mo>∗</mo><msub><mi>U</mi><mrow><mi>c</mi><mi>p</mi><mi>u</mi></mrow></msub><mo>∗</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mfrac><mi>W</mi><mi>C</mi></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N_{threads}=N_{cpu}*U_{cpu}*(1+\frac{W}{C})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">h</span><span class="mord mathnormal mtight" style="margin-right:0.02778em">r</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">u</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">u</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em"><span style="top:-2.6550000000000002em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em">C</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:0.04em"></span></span><span style="top:-3.394em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em">W</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span></span>，其中CPU数量可以通过<code>Runtime.getRuntime().availableProcessors()</code>得到。CPU周期并不影响线程池大小的唯一因素，例如上节提到的JDB连接池。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="配置threadpoolexecutor"></a>配置ThreadPoolExecutor<a class="hash-link" href="#配置threadpoolexecutor" title="Direct link to heading">#</a></h2><p>ThreadPoolExecutor构造器提供了7个参数，通过这些参数来定制化ThreadPoolExecutor：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public ThreadPoolExecutor(int corePoolSize,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                          int maximumPoolSize,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                          long keepAliveTime,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                          TimeUnit unit,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                          ThreadFactory threadFactory,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                          RejectedExecutionHandler handler)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="线程的创建与销毁"></a>线程的创建与销毁<a class="hash-link" href="#线程的创建与销毁" title="Direct link to heading">#</a></h3><p>基本大小(corePoolSize)是线程池在没有任务执行时的大小，最大大小(maximumPoolSize)是同时活动线程数量的上限。如果某个线程的空闲时间超过keepAliveTime，它将被标记为可回收的，并且线程大小超过基本大小时，线程将会被终止。线程池各个工厂方法配置的策略：</p><ul><li>newFixedThreadPool：基本大小=最大大小=传入参数值，keepAliveTime=0，无界队列</li><li>newCachedThreadPool：基本大小=0，最大大小=Integer.MAX_VALUE，超时时间=60s，SynchronousQueue</li><li>newSingleThreadPool：基本大小=最大大小=1，keepAliveTime=0，无界队列</li><li>newScheduledThreadPool：基本大小=给定值，最大大小=Integer.MAX_VALUE，keepAliveTime=0，DelayedWorkQueue</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="管理队列任务"></a>管理队列任务<a class="hash-link" href="#管理队列任务" title="Direct link to heading">#</a></h3><p>线程池通过阻塞队列workQueue保存等待执行的任务，可分为3类：无界队列、有界队列和同步移交(synchronous handoff)。newFixedThreadPool和newSingleThreadExecutor默认使用大小为Integer.MAX_VALUE的LinkedBlockingQueue(无界队列)，为了避免资源耗尽，应该使用有界队列(ArrayBlockingQueue、有界LinkedBlockingQueue、PriorityBlockingQueue)，并且注意队列大小和线程池大小同时调节。</p><p>对于非常大或者无界的线程池，使用SynchronousQueue来避免任务排队，它并不是真正的队列，而是一种在线程之间移交的机制。只有当线程池是无界的或者可以拒绝任务时，SynchronousQueue才有价值，在newCachedThreadPool就使用到了它。</p><div class="admonition admonition-caution alert alert--warning"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"></path></svg></span>caution</h5></div><div class="admonition-content"><p>只有当线程互相独立时，为线程池或工作队列设置界限才是合理的，否则会出现线程饥饿死锁问题</p></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="饱和策略"></a>饱和策略<a class="hash-link" href="#饱和策略" title="Direct link to heading">#</a></h3><p>当有界队列被填满后，由饱和策略handler来处理提交线程。Java类库实现的饱和策略有：</p><ol><li>AbortPolicy：拒绝任务，抛出未检查的RejectedException</li><li>DiscardPolicy：悄咪咪地抛弃任务</li><li>DiscardOldestPolicy：抛弃下一个将被执行任务，然后重新提交新任务，避免和优先级队列一同使用</li><li>CallerRunsPolicy：将任务回退给调用者</li></ol><p>除了使用现有的饱和策略外，还可以通过Semaphore来限制任务的提交，如下代码所示：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class BoundedExecutor {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Executor exec;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Semaphore semaphore;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public BoundedExecutor(Executor exec, int bound) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.exec = exec;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.semaphore = new Semaphore(bound);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void submitTask(final Runnable command)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            throws InterruptedException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        semaphore.acquire();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            exec.execute(new Runnable() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                public void run() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        command.run();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } finally {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        semaphore.release();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            });</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (RejectedExecutionException e) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            semaphore.release();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>BoundExecutor使用无界队列，并设置信号量上界为线程池大小加上可排队任务数量。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="线程工厂"></a>线程工厂<a class="hash-link" href="#线程工厂" title="Direct link to heading">#</a></h3><p>线程池通过线程工厂来创建线程，Executors指定的DefaultThreadFactory实现了ThreadFactory接口，它返回一个新的非守护线程，并没有包含其他特殊配置。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">// 线程工厂接口定义</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public interface ThreadFactory {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Thread newThread(Runnable r);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// Executors的静态内部类DefaultThreadFactory</span></span><span class="token-line" style="color:#393A34"><span class="token plain">static class DefaultThreadFactory implements ThreadFactory {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final AtomicInteger poolNumber = new AtomicInteger(1);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final ThreadGroup group;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final AtomicInteger threadNumber = new AtomicInteger(1);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final String namePrefix;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    DefaultThreadFactory() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        SecurityManager s = System.getSecurityManager();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        group = (s != null) ? s.getThreadGroup() :</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                Thread.currentThread().getThreadGroup();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        namePrefix = &quot;pool-&quot; +</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        poolNumber.getAndIncrement() +</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        &quot;-thread-&quot;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Thread newThread(Runnable r) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread t = new Thread(group, r,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                namePrefix + threadNumber.getAndIncrement(),</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                0);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (t.isDaemon())</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            t.setDaemon(false);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (t.getPriority() != Thread.NORM_PRIORITY)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            t.setPriority(Thread.NORM_PRIORITY);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return t;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>在许多情况下需要定制线程工厂，比如：定制UncaughtExceptionHandler、设置优先级、设置线程名称等。如下所示代码给出了一个示例：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class MyThreadFactory implements ThreadFactory {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final String poolName;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public MyThreadFactory(String poolName) { this.poolName = poolName; }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Thread newThread(Runnable runnable) { return new MyAppThread(runnable, poolName);}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class MyAppThread extends Thread {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static final String DEFAULT_NAME = &quot;MyAppThread&quot;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static volatile boolean debugLifecycle = false;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final AtomicInteger created = new AtomicInteger();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final AtomicInteger alive = new AtomicInteger();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final Logger log = Logger.getAnonymousLogger();</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public MyAppThread(Runnable r) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this(r, DEFAULT_NAME);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public MyAppThread(Runnable runnable, String name) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        super(runnable, name + &quot;-&quot; + created.incrementAndGet());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            public void uncaughtException(Thread t, Throwable e) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                log.log(Level.SEVERE, &quot;UNCAUGHT in thread &quot; + t.getName(), e);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void run() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Copy debug flag to ensure consistent value throughout.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        boolean debug = debugLifecycle;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (debug) log.log(Level.FINE, &quot;Created &quot; + getName());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            alive.incrementAndGet();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            super.run();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            alive.decrementAndGet();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (debug) log.log(Level.FINE, &quot;Exiting &quot; + getName());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ... 一些getter和setter</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>MyAppThread可以定制线程名称便于区分，维护创建线程、存活线程个数等统计信息。此外，若需要利用安全策略控制对代码库的访问权限，还可以通过Executors的PrivilegedThreadFactory来定制线程工厂。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="构造后定制threadpoolexecutor"></a>构造后定制ThreadPoolExecutor<a class="hash-link" href="#构造后定制threadpoolexecutor" title="Direct link to heading">#</a></h3><p>在调用完ThreadPoolExecutor构造函数后，仍可以通过setter修改构造参数值。除了newSingleThreadExecutor外，Executors的其他工厂方法都可以将返回对象转为ThreadPoolExecutor来修改配置：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">ExecutorService exec = Executors.newCachedThreadPool();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">if(exec instanceof ThreadPoolExecutor)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ((ThreadPoolExecutor) exec).setCorePoolSize(10);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">else</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    throw new AssertionError(&quot;Oops, bad assumption&quot;);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>Executors还提供静态方法unconfigurableExecutorService，将ExecutorService包装成不可修改配置的DelegatedExecutorService。由于newSingleThreadExecutor返回的DelegatedScheduledExecutorService对象继承于DelegatedExecutorService，因此它是不可修改的。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="扩展threadpoolexecutor"></a>扩展ThreadPoolExecutor<a class="hash-link" href="#扩展threadpoolexecutor" title="Direct link to heading">#</a></h2><p>ThreadPoolExecutor的扩展通过在子类重写beforeExecute、afterExecute和terminated实现。如果任务执行完成或者抛出异常，afterExecute仍会执行(任务抛出错误除外)，当beforeExecute执行抛出RuntimeException，则任务和afterExecute都不会执行。线程池完成关闭后调用terminated方法，即所有任务完成并且工作线程已经关闭后，terminated方法可以用于释放Executor中分配的资源。</p><p>如下所示代码通过自定义线程池，添加日志记录和统计信息收集。beforeExecute方法将任务开始时间保存在ThreadLocal中，由afterExecute方法读取来计算任务运行时间，并通过AtomicLong来统计已处理任务和总处理时间：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class TimingThreadPool extends ThreadPoolExecutor {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public TimingThreadPool() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        super(1, 1, 0L, TimeUnit.SECONDS, null);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final ThreadLocal&lt;Long&gt; startTime = new ThreadLocal&lt;Long&gt;();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Logger log = Logger.getLogger(&quot;TimingThreadPool&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final AtomicLong numTasks = new AtomicLong();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final AtomicLong totalTime = new AtomicLong();</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected void beforeExecute(Thread t, Runnable r) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        super.beforeExecute(t, r);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        log.fine(String.format(&quot;Thread %s: start %s&quot;, t, r));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        startTime.set(System.nanoTime());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected void afterExecute(Runnable r, Throwable t) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            long endTime = System.nanoTime();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            long taskTime = endTime - startTime.get();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            numTasks.incrementAndGet();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            totalTime.addAndGet(taskTime);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            log.fine(String.format(&quot;Thread %s: end %s, time=%dns&quot;,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    t, r, taskTime));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            super.afterExecute(r, t);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected void terminated() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            log.info(String.format(&quot;Terminated: avg time=%dns&quot;,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    totalTime.get() / numTasks.get()));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            super.terminated();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="递归算法的并行化"></a>递归算法的并行化<a class="hash-link" href="#递归算法的并行化" title="Direct link to heading">#</a></h2><p>当串行循环中的各个迭代操作之间彼此<strong>独立</strong>，并且每个迭代操作工作量大于管理新任务的，此时该串行循环就适合并行化，例如第6章中的Renderer。在一些递归设计中同样可以使用相同方法，如下代码所示：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public &lt;T&gt; void sequentialRecursive(List&lt;Node&lt;T&gt;&gt; nodes,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                        Collection&lt;T&gt; results) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (Node&lt;T&gt; n : nodes) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        results.add(n.compute());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        sequentialRecursive(n.getChildren(), results);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public &lt;T&gt; void parallelRecursive(final Executor exec,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    List&lt;Node&lt;T&gt;&gt; nodes,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    final Collection&lt;T&gt; results) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (final Node&lt;T&gt; n : nodes) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        exec.execute(new Runnable() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            public void run() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                results.add(n.compute());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        parallelRecursive(exec, n.getChildren(), results);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>由于每个迭代操作不依赖后续递归迭代的结果，因此可以并行化。为了获取最终结果，通过shutdown、awaitTermination方法实现，代码如下所示：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public &lt;T&gt; Collection&lt;T&gt; getParallelResults(List&lt;Node&lt;T&gt;&gt; nodes)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        throws InterruptedException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ExecutorService exec = Executors.newCachedThreadPool();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Queue&lt;T&gt; resultQueue = new ConcurrentLinkedQueue&lt;T&gt;();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    parallelRecursive(exec, nodes, resultQueue);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    exec.shutdown();        // 发出关闭执行，并无限期等待所有任务结束</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    exec.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return resultQueue;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="示例谜题框架"></a>示例：谜题框架<a class="hash-link" href="#示例谜题框架" title="Direct link to heading">#</a></h3><p>串行递归并行化的一项重要应用就是解决这样一些谜题：找出一系列操作从初始状态转换到目标状态。问题定义为：一个初始位置，一个目标位置以及判断是否有效移动的规则集(包含指定位置处的合法移动以及每次移动的结果位置)。以“搬箱子”</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public interface Puzzle &lt;P, M&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    P initialPosition();</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    boolean isGoal(P position);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Set&lt;M&gt; legalMoves(P position);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    P move(P position, M move);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class PuzzleNode &lt;P, M&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    final P pos;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    final M move;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    final PuzzleNode&lt;P, M&gt; prev;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public PuzzleNode(P pos, M move, PuzzleNode&lt;P, M&gt; prev) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.pos = pos;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.move = move;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.prev = prev;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 将之前所有移动操作作为列表返回</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    List&lt;M&gt; asMoveList() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;M&gt; solution = new LinkedList&lt;M&gt;();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (PuzzleNode&lt;P, M&gt; n = this; n.move != null; n = n.prev)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            solution.add(0, n.move);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return solution;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>以下search方法给出谜题框架的串行化解决方案，它通过深度优先搜索找到解决方案(不一定是最优方案)。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class SequentialPuzzleSolver &lt;P, M&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Puzzle&lt;P, M&gt; puzzle;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Set&lt;P&gt; seen = new HashSet&lt;P&gt;();</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public SequentialPuzzleSolver(Puzzle&lt;P, M&gt; puzzle) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.puzzle = puzzle;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public List&lt;M&gt; solve() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        P pos = puzzle.initialPosition();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return search(new PuzzleNode&lt;P, M&gt;(pos, null, null));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private List&lt;M&gt; search(PuzzleNode&lt;P, M&gt; node) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!seen.contains(node.pos)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            seen.add(node.pos);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (puzzle.isGoal(node.pos))</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                return node.asMoveList();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (M move : puzzle.legalMoves(node.pos)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                P pos = puzzle.move(node.pos, move);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                PuzzleNode&lt;P, M&gt; child = new PuzzleNode&lt;P, M&gt;(pos, move, node);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                List&lt;M&gt; result = search(child);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (result != null)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return result;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>如下代码所示给出并发的谜题解答器。在串行版本中通过Set来保存已经搜索过的位置，避免无限循环，在并发版本中使用ConcurrentHashMap来替代，因为要确保Put-If-Absent操作线程安全性。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class ConcurrentPuzzleSolver &lt;P, M&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Puzzle&lt;P, M&gt; puzzle;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final ExecutorService exec;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final ConcurrentMap&lt;P, Boolean&gt; seen;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected final ValueLatch&lt;PuzzleNode&lt;P, M&gt;&gt; solution = new ValueLatch&lt;PuzzleNode&lt;P, M&gt;&gt;();</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ConcurrentPuzzleSolver(Puzzle&lt;P, M&gt; puzzle) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.puzzle = puzzle;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.exec = initThreadPool();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.seen = new ConcurrentHashMap&lt;P, Boolean&gt;();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (exec instanceof ThreadPoolExecutor) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            ThreadPoolExecutor tpe = (ThreadPoolExecutor) exec;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            tpe.setRejectedExecutionHandler(new ThreadPoolExecutor.DiscardPolicy());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private ExecutorService initThreadPool() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return Executors.newCachedThreadPool();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public List&lt;M&gt; solve() throws InterruptedException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            P p = puzzle.initialPosition();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            exec.execute(newTask(p, null, null));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // getValue阻塞直到找到答案</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            PuzzleNode&lt;P, M&gt; solnPuzzleNode = solution.getValue();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return (solnPuzzleNode == null) ? null : solnPuzzleNode.asMoveList();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 某个线程找到答案后又getValue放行，此时可以关闭线程池</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            exec.shutdown();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected Runnable newTask(P p, M m, PuzzleNode&lt;P, M&gt; n) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new SolverTask(p, m, n);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected class SolverTask extends PuzzleNode&lt;P, M&gt; implements Runnable {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        SolverTask(P pos, M move, PuzzleNode&lt;P, M&gt; prev) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            super(pos, move, prev);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void run() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (solution.isSet()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    || seen.putIfAbsent(pos, true) != null)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                return; // 找到答案或者遍历过该位置</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (puzzle.isGoal(pos))</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                solution.setValue(this);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            else</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                for (M m : puzzle.legalMoves(pos))</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    exec.execute(newTask(puzzle.move(pos, m), m, this));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>为了在找到一个答案后停止，实现带结果的闭锁ValueLatch，代码如下所示：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class ValueLatch &lt;T&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private T value = null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final CountDownLatch done = new CountDownLatch(1);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean isSet() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return (done.getCount() == 0);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // setValue是同步的，确保只有一个线程执行设置操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public synchronized void setValue(T newValue) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!isSet()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            value = newValue;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            done.countDown();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public T getValue() throws InterruptedException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        done.await();       // 主线程调用getValue会被阻塞</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        synchronized (this) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return value;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>在solve方法的finally块中，第一个找到答案的线程会关闭线程池，终止所有任务的同时也阻止新的任务被提交。为了避免处理RejectedExcutionException，将拒绝策略设置为抛弃已提交任务。而正在执行的任务都会失败使得Executor结束。</p><p>如果不存在答案，那么getSolution方法永远阻塞。为了处理这种情况，一种方式是记录活动任务数量，在该值为零时将答案设置为null，代码如下所示：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class PuzzleSolver &lt;P,M&gt; extends ConcurrentPuzzleSolver&lt;P, M&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    PuzzleSolver(Puzzle&lt;P, M&gt; puzzle) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        super(puzzle);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final AtomicInteger taskCount = new AtomicInteger(0);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected Runnable newTask(P p, M m, PuzzleNode&lt;P, M&gt; n) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new CountingSolverTask(p, m, n);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    class CountingSolverTask extends SolverTask {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        CountingSolverTask(P pos, M move, PuzzleNode&lt;P, M&gt; prev) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            super(pos, move, prev);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            taskCount.incrementAndGet();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void run() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                super.run();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            } finally {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (taskCount.decrementAndGet() == 0)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    solution.setValue(null);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>除此之外，计算时间可能很长，此时可以加上时间限制：在ValueLatch中实现一个限时的getValue(即使用限时版本的await方法)，当getValue超时，那么关闭线程池并抛出异常。还可以基于其他策略关闭线程池，比如只搜索特定数量的位置。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="总结"></a>总结<a class="hash-link" href="#总结" title="Direct link to heading">#</a></h2><ol><li>ThreadPoolExecutor参数设置(构造前参数指定，构造后setXxx)</li><li>定制化线程工厂</li><li>beforeExecute、afterExecute、terminated方法扩展ThreadPoolExecutor</li><li>递归算法并行化的代码实现</li></ol></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-tags-row row margin-bottom--sm"><div class="col"><b>Tags:</b><ul class="tags_2ga9 padding--none margin-left--sm"><li class="tag_11ep"><a class="tag_1Okp tagRegular_3MiF" href="/docs/tags/java-concurrency">Java Concurrency</a></li><li class="tag_11ep"><a class="tag_1Okp tagRegular_3MiF" href="/docs/tags/reading-notes">ReadingNotes</a></li></ul></div></div><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/kayhaw/kayhaw.github.io/edit/master/website/docs/Java并发编程实战\Java-Concurrency-in-Practice-Chap08.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_13-_"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap07"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 取消与关闭</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/Java并发编程实战/Java-Concurrency-in-Practice-Chap10"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">避免活跃性危险 »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#在任务与执行策略之间的隐性耦合" class="table-of-contents__link">在任务与执行策略之间的隐性耦合</a><ul><li><a href="#线程饥饿死锁" class="table-of-contents__link">线程饥饿死锁</a></li><li><a href="#运行时间较长的任务" class="table-of-contents__link">运行时间较长的任务</a></li></ul></li><li><a href="#设置线程池" class="table-of-contents__link">设置线程池</a></li><li><a href="#配置threadpoolexecutor" class="table-of-contents__link">配置ThreadPoolExecutor</a><ul><li><a href="#线程的创建与销毁" class="table-of-contents__link">线程的创建与销毁</a></li><li><a href="#管理队列任务" class="table-of-contents__link">管理队列任务</a></li><li><a href="#饱和策略" class="table-of-contents__link">饱和策略</a></li><li><a href="#线程工厂" class="table-of-contents__link">线程工厂</a></li><li><a href="#构造后定制threadpoolexecutor" class="table-of-contents__link">构造后定制ThreadPoolExecutor</a></li></ul></li><li><a href="#扩展threadpoolexecutor" class="table-of-contents__link">扩展ThreadPoolExecutor</a></li><li><a href="#递归算法的并行化" class="table-of-contents__link">递归算法的并行化</a><ul><li><a href="#示例谜题框架" class="table-of-contents__link">示例：谜题框架</a></li></ul></li><li><a href="#总结" class="table-of-contents__link">总结</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">读书笔记</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items"><li class="footer__item"><a href="https://www.zhihu.com/people/xiao-ke-dou-7" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>知乎<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/kayhaw" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://gitee.com/kayhaw" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Gitee<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 何轲(Kay Haw). Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.7de17fe8.js"></script>
<script src="/assets/js/main.00935a8a.js"></script>
</body>
</html>